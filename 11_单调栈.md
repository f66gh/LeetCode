# 11_单调栈

[739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/description/)

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // 单调栈：让栈里边的数值始终自底向上是降序，并且压入栈的是索引
        int n = temperatures.size();
        stack<int> st;
        vector<int> res(n, 0);
        for(int i = 0; i < n; i++){
            // 找到了比自己大的
            while(!st.empty() && temperatures[st.top()] < temperatures[i]){
                res[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);
        }
        return res;
    }
};
```

[496. 下一个更大元素 I - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-i/)

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // 由于整数互不相同，直接用哈希表
        unordered_map<int, int> map; // map存的是<值，下一个更大值>
        stack<int> st; // st存数值就行
        int n = nums2.size();
        int m = nums1.size();
        vector<int> res(m, -1);
        for(int i = 0; i < n; i++){
            while(!st.empty() && st.top() < nums2[i]){
                map[st.top()] = nums2[i];
                st.pop();
            }
            st.push(nums2[i]);
        }
        for(int i = 0; i < m; i++){
            // 规范检查 key 是否存在
            if(map.count(nums1[i])) res[i] = map[nums1[i]];
        }
        return res;
    }
};
```

[503. 下一个更大元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-ii/)

**破环成链**（模运算技巧）

处理循环数组最通用的套路是：**把数组复制一份拼在后面**。

**优化技巧：** 我们不需要真的申请双倍空间去拼数组，只需要在遍历时**假装**数组变长了。

- 遍历范围从 `0` 到 `2 * n - 1`。
- 访问元素时使用取模操作：`nums[i % n]`。

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        // 标准解法：破环成链（模运算技巧）
        int n = nums.size();
        stack<int> st; // st存的是下标
        vector<int> res(n, -1);
        for(int i = 0; i < 2 * n; i++){
            while(!st.empty() && nums[st.top()] < nums[i % n]){
                res[st.top()] = nums[i % n];
                st.pop();
            }
            // 注意，当i大于n之后没必要入栈了，我们只是比较才多循环一次
            if(i < n) st.push(i);
        }
        return res;
    }
};
```

