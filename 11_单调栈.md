# 11_单调栈

[739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/description/)

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // 单调栈：让栈里边的数值始终自底向上是降序，并且压入栈的是索引
        int n = temperatures.size();
        stack<int> st;
        vector<int> res(n, 0);
        for(int i = 0; i < n; i++){
            // 找到了比自己大的
            while(!st.empty() && temperatures[st.top()] < temperatures[i]){
                res[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);
        }
        return res;
    }
};
```

[496. 下一个更大元素 I - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-i/)

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // 由于整数互不相同，直接用哈希表
        unordered_map<int, int> map; // map存的是<值，下一个更大值>
        stack<int> st; // st存数值就行
        int n = nums2.size();
        int m = nums1.size();
        vector<int> res(m, -1);
        for(int i = 0; i < n; i++){
            while(!st.empty() && st.top() < nums2[i]){
                map[st.top()] = nums2[i];
                st.pop();
            }
            st.push(nums2[i]);
        }
        for(int i = 0; i < m; i++){
            // 规范检查 key 是否存在
            if(map.count(nums1[i])) res[i] = map[nums1[i]];
        }
        return res;
    }
};
```

[503. 下一个更大元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-ii/)

**破环成链**（模运算技巧）

处理循环数组最通用的套路是：**把数组复制一份拼在后面**。

**优化技巧：** 我们不需要真的申请双倍空间去拼数组，只需要在遍历时**假装**数组变长了。

- 遍历范围从 `0` 到 `2 * n - 1`。
- 访问元素时使用取模操作：`nums[i % n]`。

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        // 标准解法：破环成链（模运算技巧）
        int n = nums.size();
        stack<int> st; // st存的是下标
        vector<int> res(n, -1);
        for(int i = 0; i < 2 * n; i++){
            while(!st.empty() && nums[st.top()] < nums[i % n]){
                res[st.top()] = nums[i % n];
                st.pop();
            }
            // 注意，当i大于n之后没必要入栈了，我们只是比较才多循环一次
            if(i < n) st.push(i);
        }
        return res;
    }
};
```

[42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/description/)

单调栈做法，横向计算雨水量

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        // 单调栈做法，栈底到栈顶是单调递增的(栈存的是下标)
        stack<int> st;
        int sum = 0;
        int n = height.size();
        for(int i = 0; i < n; i++){
            // 注意这是横着算的
            while(!st.empty() && height[st.top()] < height[i]){
                // 找到坑底
                int buttom = height[st.top()];
                st.pop();
                // 找到左墙
                if(st.empty()) break;
                int left = height[st.top()];
                int h = min(left, height[i]) - buttom;
                int w = i - st.top() - 1;
                // 计算这一格的蓄水量
                sum += h * w;
            }
            st.push(i);
        }
        return sum;
    }
};
```

双指针做法，非常的巧妙

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        // 双指针做法
        int left_max = 0;
        int right_max = 0;
        int left = 0;
        int right = height.size() - 1;
        int sum = 0;
        while(left < right){
            left_max = max(left_max, height[left]);
            right_max = max(right_max, height[right]);
            if(left_max < right_max){
                sum += left_max - height[left];
                left++;
            }
            else{
                sum += right_max - height[right];
                right--;
            }
        }
        return sum;
    }
};
```

[84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

太抽象了，直接背的答案

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 单调栈，从栈底到栈顶是单调递增的
        int n = heights.size();
        stack<int> st; // 存下标
        int max_size = 0;
        vector<int> newHeights(n + 2, 0);
        for(int i = 1; i <= n; i++) newHeights[i] = heights[i - 1];
        for(int i = 0; i < n + 2; i++){
            while(!st.empty() && newHeights[i] < newHeights[st.top()]){
                int mid = st.top(); // 要求高度的柱子
                st.pop();
                if(!st.empty()){
                    int left = st.top(); // 右边界
                    int right = i; // 左边界
                    int w = right - left - 1;
                    int h = newHeights[mid];
                    max_size = max(max_size, w * h);
                }
            }
            st.push(i);
        }
        return max_size;
    }
};
```

