# 哈希表

## 有效的字母异构词

![image-20250102154753372](./pic/image-20250102154753372.png)

### 哈希表

哈希表不一定非得用函数，可以用计数排序思想。

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int alphabet[26] = {0};
        for(int i = 0; i < s.size(); i++){
            alphabet[s[i] - 'a']++;
        }
        for(int i = 0; i < t.size(); i++){
            if(alphabet[t[i] - 'a'] == 0){
                return false;
            }
            else{
                alphabet[t[i] - 'a']--;
            }
        }
        for(int i = 0 ; i < 26; i++){
            if(alphabet[i] != 0){
                return false;
            }
        }
        return true;
    }
};
```

### 排序

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.size() != t.size()) return false;
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return t == s;
    }
};
```

![image-20250102154849550](./pic/image-20250102154849550.png)

自己写的代码，虽然是一坨但真不容易：

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        //用排序做
        vector<string>sortList; // 排序数组
        vector<vector<string>> res;
        bool flag;
        for(string str : strs){// 遍历输入字符串数组
            string temp = str;
            flag = false; // 判断字符串的异位词是否第一次出现
            sort(temp.begin(), temp.end());// 排序
            for(int i=0; i<sortList.size();i++){
                string sortStr = sortList[i];
                if(sortStr == temp){ // 当从排序数组匹配到异位词时
                    res[i].push_back(str);
                    flag = true;
                }
            }
            if(!flag){ // 若未匹配到异位词
                vector<string> arr;
                arr.push_back(str);
                res.push_back(arr);// 加入一个组
                sortList.push_back(temp);//加入排好的异位词
            }
        }
        return res;
    }
};
```

用HashMap优化上述代码：

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> sortedMap;
        for(string str : strs){
            string sortedStr = str;
            sort(sortedStr.begin(), sortedStr.end());
            sortedMap[sortedStr].push_back(str);// 有这个下标就直接加入进对应数组，没有就新建下标
        }
        //将map转化为对应格式
        vector<vector<string>> res;
        for(auto pair : sortedMap){
            res.push_back(pair.second);
        }
        return res;
    }
};
```

时间复杂度：O(MKlogK)，M是数组长度，K是单个字符串长度，KlogK是排序用。

![image-20250102163421453](./pic/image-20250102163421453.png)

变态案例爆时间（排序做法）：

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        string sortedStr = p;
        sort(sortedStr.begin(), sortedStr.end());
        if(p.length() > s.length()) return res;
        for(int i = 0; i < s.length() - p.length() + 1; i++){
            string temp;
            for(int j = 0; j<p.length(); j++){
                temp += s[i+j];
            }
            sort(temp.begin(), temp.end());
            if(temp == sortedStr){
                res.push_back(i);
            }
        }
        return res;
    }
};
```

自己写的计数方法（时间仍然不咋地）：

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        unordered_map<char,int> countMap;
        bool flag;
        if(p.length() > s.length()) return res;
        for(char c : p) countMap[c]++;// 初始化map
        for(int i = 0; i < s.length() - p.length() + 1; i++){
            auto tempMap = countMap;
            flag = true;
            for(int j = 0; j < p.length(); j++){
                if(--tempMap[s[i+j]] < 0) {
                    flag = false;
                    break;
                }
            }
            if(flag) res.push_back(i);
        }
        return res;
    }
};
```



## 两个数组的交集

![image-20250102133132388](./pic/image-20250102133132388.png)

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        unordered_set<int> res;
        for(int i : nums2){
            // 这里的find(i)和end()返回的都是迭代器，不是具体的值
            if(nums_set.find(i) != res.end()){
                res.insert(i);
            }
        }
        return vector<int>(res.begin(), res.end());
    }
};
```

![image-20250102144846697](./pic/image-20250102144846697.png)

```c++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> m;
        vector<int> res;
        for(int num : nums1) m[num]++;
        for(int num : nums2){
            if(m[num]){
                m[num]--;
                res.push_back(num);
            }
        }
        return res;
    }
};
```

