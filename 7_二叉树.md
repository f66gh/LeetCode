# 二叉树

## 二叉树的深度优先遍历

前序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }

    void traversal(TreeNode* root, vector<int> &vec){
        if(root == NULL) return;
        vec.push_back(root->val);
        traversal(root->left, vec);
        traversal(root->right, vec);
    }
};
```

后序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }

    void traversal(TreeNode* root, vector<int> &vec){
        if(root == NULL) return;
        traversal(root->left, vec);
        traversal(root->right, vec);
        vec.push_back(root->val);
    }
};
```

中序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }

    void traversal(TreeNode* root, vector<int> &vec){
        if(root == NULL) return;
        traversal(root->left, vec);
        vec.push_back(root->val);
        traversal(root->right, vec);
    }
};
```

[404. 左叶子之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-left-leaves/description/)

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        int res = 0;
        depth(root, res);
        return res;
    }

    void depth(TreeNode* root, int& res){
        TreeNode* left;
        if(root->left) {
            left = root->left;
            if(left->left || left->right) depth(left, res);
            else res += left->val;
        }
        if(root->right) depth(root->right, res);
    }
};
```



## 层序遍历

[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

**递归法**

不需要队列

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        order(root, res, 0);
        return res;
    }

    void order(TreeNode* node, vector<vector<int>> &res,int depth){
        if(node == NULL) return;
        if(res.size() == depth) res.push_back(vector<int>());
        res[depth].push_back(node->val);
        order(node->left, res, depth + 1);
        order(node->right, res, depth + 1);
    }
};
```

**迭代法（正常解法）**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if(root != NULL) {
            que.push(root);
        };
        while(!que.empty()){
            // 保持队列中只有一层的节点
            vector<int> curLevel;
            int curSize = que.size();
            for(int i = 0; i < curSize; i++){
                TreeNode* cur = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
                que.pop();
                curLevel.push_back(cur->val);
            }
            res.push_back(curLevel);
        }
        return res;
    }
};
```

[107. 二叉树的层序遍历 II - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if(root != NULL) {
            que.push(root);
        };
        while(!que.empty()){
            vector<int> curLevel;
            int curSize = que.size();
            for(int i = 0; i < curSize; i++){
                TreeNode* cur = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
                que.pop();
                curLevel.push_back(cur->val);
            }
            res.push_back(curLevel);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

[199. 二叉树的右视图 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-right-side-view/description/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<vector<int>> resLevel;
        queue<TreeNode*> que;
        if(root != NULL) {
            que.push(root);
        };
        while(!que.empty()){
            // 保持队列中只有一层的节点
            vector<int> curLevel;
            int curSize = que.size();
            for(int i = 0; i < curSize; i++){
                TreeNode* cur = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
                que.pop();
                curLevel.push_back(cur->val);
            }
            resLevel.push_back(curLevel);
        }
        vector<int> res;
        for(auto v : resLevel){
            res.push_back(v.back());
        }
        return res;
    }
};
```

[637. 二叉树的层平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

```cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ave;
        queue<TreeNode*> que;
        if(root != NULL) {
            que.push(root);
        };
        while(!que.empty()){
            // 保持队列中只有一层的节点
            int curSize = que.size();
            double sum = 0;
            for(int i = 0; i < curSize; i++){
                TreeNode* cur = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
                que.pop();
                sum += cur->val;
            }
            ave.push_back(sum / curSize);
        }
        return ave;
    }
};
```

[429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        queue<Node*> que;
        if(root == nullptr) return res;
        que.push(root);
        while(!que.empty()){
            vector<int> level;
            int size = que.size();
            for(int i = 0; i < size; i++){
                Node* n = que.front();
                level.push_back(n->val);
                que.pop();
                for(int i = 0; i < n->children.size(); i++){
                    if(n->children[i]) {
                        que.push(n->children[i]);
                    }
                }
            }
            res.push_back(level);
        }
        return res;
    }
};
```

[515. 在每个树行中找最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```cpp
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if(root != NULL) {
            que.push(root);
        };
        while(!que.empty()){
            int curSize = que.size();
            int max = INT_MIN;
            for(int i = 0; i < curSize; i++){
                TreeNode* cur = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
                que.pop();
                if(cur->val > max) max = cur->val;
            }
            res.push_back(max);
        }
        return res;
    }
};
```

[116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        if(root == NULL) return root;
        queue<Node*> que;
        que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                Node* cur = que.front();
                que.pop();
                if(i != size - 1) cur->next = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return root;
    }
};
```

[117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/)

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        if(root == NULL) return root;
        queue<Node*> que;
        que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                Node* cur = que.front();
                que.pop();
                if(i != size - 1) cur->next = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return root;
    }
};
```

[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/664505194/)

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> que;
        if(root != NULL) {
            que.push(root);
        };
        while(!que.empty()){
            res++;
            int curSize = que.size();
            for(int i = 0; i < curSize; i++){
                TreeNode* cur = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
                que.pop();
            }
        }
        return res;
    }
};
```

[111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> que;
        if(root != NULL) {
            que.push(root);
        };
        while(!que.empty()){
            res++;
            int curSize = que.size();
            for(int i = 0; i < curSize; i++){
                TreeNode* cur = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
                if(!cur->left && !cur->right) { 
                    return res;
                };
                que.pop();
            }
        }
        return res;
    }
};
```

## 翻转二叉树

[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/description/)

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        traversal(root);
        return root;
    }

    void traversal(TreeNode* root){
        if(root == NULL) return;
        TreeNode *cur = root->left;
        root->left = root->right;
        root->right = cur;
        traversal(root->left);
        traversal(root->right);
    }
};
```

## 对称二叉树

[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/description/)

```cpp
class Solution {
public:
    //这道题用递归好一点
    bool isMirror(TreeNode* t1, TreeNode* t2){
        if(t1 == NULL && t2 == NULL) return true;
        // 注意这里的判断条件
        if(t1 == NULL || t2 == nullptr || t1->val != t2->val) return false;
        // 比较t1的左子树和t2的右子树 和 t1的右子树和t2的左子树
        return isMirror(t1->left, t2->right) && isMirror(t1->right, t2->left);
    }
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr) return true;
        return isMirror(root->left, root->right);
    }
};
```

## 完全二叉树的节点个数

[222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/)

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        int res = 0;
        if(root != nullptr) order(root, res);
        return res;
    }

    void order(TreeNode* root, int &res){
        res++;
        if(root->left) order(root->left, res);
        if(root->right) order(root->right, res);
    }
};
```

这个算法的时间复杂度 O((logN)2)，可以理解为：**总时间 = (递归调用的次数) × (每次调用中非递归部分所做的工作)**



```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        int left_depth = 0, right_depth = 0;
        TreeNode* left_child = root->left; 
        TreeNode* right_child = root->right; 
        // 这两行是O(logN)
        while(left_child != nullptr) {
            left_child = left_child->left;
            left_depth++;
        }
        while(right_child != nullptr) {
            // 注意这里是left，我们要判断左右子树是否为满二叉树，非常关键
            right_child = right_child->left;
            right_depth++;
        }
        // 这两行递归调用是O(logN)
        if(left_depth == right_depth) return (1 << left_depth) + countNodes(root->right);
        else return (1 << right_depth) + countNodes(root->left);
    }
};
```

## 判断平衡二叉树

[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/description/)

需要自底向上遍历（后序遍历），这样能避免重复计算下面节点的高度。

```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(root == nullptr) return true;
        return countHeight(root, 0) == -1 ? false : true;
    }

    int countHeight(TreeNode* root, int height){
        int leftHeight = height, rightHeight = height;
        if(root->left) leftHeight = countHeight(root->left, height + 1);
        // 注意剪枝
        if(leftHeight == -1) return -1;
        if(root->right) rightHeight = countHeight(root->right, height + 1);
        if(rightHeight == -1) return -1;
        if(abs(leftHeight - rightHeight) > 1) return -1;
        else return max(leftHeight, rightHeight);
    }
};
```

## 二叉树所有路径

[257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/)

```cpp
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        string str = to_string(root->val);
        if(!root->left && !root->right) {
            res.push_back(str);
            return res;
        }
        if(root->left) path(root->left, str, res);
        if(root->right) path(root->right, str, res);
        return res;
    }

    void path(TreeNode* root, string str, vector<string> &res){
        str = str + "->" + to_string(root->val);
        if(root->left) path(root->left, str, res); 
        if(root->right) path(root->right, str, res); 
        if(!root->left && !root->right) res.push_back(str);
    }
};
```

## 找树左下角的值

[513. 找树左下角的值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-bottom-left-tree-value/)

BFS方法，空间复杂度是O(W)，由树的最宽处决定。

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode* > que;
        que.push(root);
        int res = 0;
        while(!que.empty()){
            int size = que.size();
            res = que.front()->val;
            for(int i = 0; i < size; i++){
                TreeNode* cur = que.front();
                que.pop();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return res;
    }
};
```

DFS：我们也可以用递归的方式来解决。我们需要遍历整个树，并记录遇到的**最大深度**。

- 定义一个变量 `max_depth` 记录已发现的最大深度，另一个变量 `result` 记录该深度最左节点的值。
- 我们进行深度优先遍历，并传入当前节点的深度 `current_depth`。
- 当我们发现一个节点的 `current_depth` 大于 `max_depth` 时，意味着我们第一次到达了一个更深的层级。因为我们总是先遍历左子树，所以这个节点一定是当前最深层的最左节点。此时，我们更新 `max_depth` 和 `result`。

空间复杂度是O(H)，由树的最大高度决定。

```cpp
class Solution {
private:
    int max_depth = 0;
    int res = 0;
    void DFS(TreeNode* root, int depth){
        if(root == nullptr) return;

        if(depth > max_depth){
            res = root->val;
            max_depth = depth;
        }
        
        DFS(root->left, depth + 1);
        DFS(root->right, depth + 1);
    }

public:
    int findBottomLeftValue(TreeNode* root) {
       DFS(root, 1);
       return res; 
    }
};
```

## 路径总和

 [112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/description/)

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        dfs(root, 0);
        if(find(vec.begin(), vec.end(), targetSum) != vec.end()) return true;
        return false;
    }
private:  
    vector<int> vec;
    void dfs(TreeNode* root,  int sum){
        if(root == nullptr) return;
        sum += root->val;
        if(root->left) dfs(root->left, sum);
        if(root->right) dfs(root->right, sum);
        if(!root->left && !root->right) vec.push_back(sum);
    }
};
```

优化的深度优先遍历（懒得写了）：

 减少了额外的空间开销。

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        // 如果根节点为空，直接返回 false
        if (root == nullptr) {
            return false;
        }

        // 检查当前节点是否是叶子节点
        if (root->left == nullptr && root->right == nullptr) {
            // 如果是叶子节点，判断其值是否等于目标和
            return root->val == targetSum;
        }

        // 递归地在左子树和右子树中查找
        // targetSum 减去当前节点的值，作为新的目标和传递给子节点
        // 使用 || 短路特性，一旦找到一个 true，就不会再计算另一个
        return hasPathSum(root->left, targetSum - root->val) || 
               hasPathSum(root->right, targetSum - root->val);
    }
};
```

当树很深时，防止树深度极大的情况下发生栈溢出，可以考虑层序遍历。

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;
        stack<pair<TreeNode*, int>> st;
        st.push({root, root->val});
        while(!st.empty()){
            auto [node, curSum] =  st.top();
            st.pop();
            if(!node->left && !node->right && curSum == targetSum) return true;

            if(node->left) st.push({node->left, curSum + node->left->val});
            if(node->right) st.push({node->right, curSum + node->right->val});
        }

        return false;
    }
};
```

##  中序与后续遍历构造二叉树

[106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

经典的错误，标准的零分：

1. **指针传递问题 (最核心的错误)** 你的 `createTree` 函数签名是 `void createTree(TreeNode* root, ...)`。在C++中，这是**按值传递**指针。这意味着函数接收的是指针的一个**副本**。 当你在 base case 中执行 `root = nullptr;` 时，你只是将这个**副本**指针置为空，而调用它的上层函数中的 `root->left` 或 `root->right` 指针并没有被改变。它依然指向你之前用 `new TreeNode` 分配的内存，但这块内存没有被正确初始化，也没有被正确链接。

2. **递归时创建不必要的节点** 在递归调用之前，你无条件地执行了 `root->left = new TreeNode;` 和 `root->right = new TreeNode;`。即使左子树或右子树是空的，你还是创建了新节点。这会导致树的结构错误，并造成内存泄漏。

3. **效率问题：频繁复制数组** 你的函数参数 `vector<int> inorder, vector<int> postorder` 是按值传递的。在每一次递归调用中，你都会创建 `leftInorder`, `rightInorder`, `leftPostorder`, `rightPostorder` 这四个新的 `vector`。对于一个大树来说，这会涉及大量的数组复制操作，导致时间和空间复杂度过高，很可能超时或超内存。

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        TreeNode* root = new TreeNode;   
        createTree(root, inorder, postorder);
        return root;
    }
private:
    void createTree(TreeNode* root, vector<int>inorder, vector<int> postorder){
        if(inorder.size() == 0) {
            root = nullptr;
            return;
        }
        // 给当前节点赋值
        root->val = *(postorder.end() - 1); 
        if(inorder.size() != 1){
            // 找当前根节点在中序遍历节点的位置
            auto it = find(inorder.begin(), inorder.end(), root->val);
            int dis = distance(inorder.begin(), it);
            // 分割中序遍历数组
            vector<int> leftInorder(inorder.begin(), inorder.begin() + dis);
            vector<int> rightInorder(inorder.begin() + dis + 1, inorder.end());
            // 分割后序遍历数组
            vector<int> leftPostorder(postorder.begin(), postorder.begin() + dis);
            vector<int> rightPostorder(postorder.begin() + dis, postorder.end() - 1);
            // 新建节点
            root->left = new TreeNode;
            root->right = new TreeNode;
            //递归
            createTree(root->left, leftInorder, leftPostorder);
            createTree(root->right, rightInorder, rightPostorder);
        }
        else{
            root->left = nullptr;
            root->right = nullptr;
        }
    }
};
```

使用了哈希表和传递数组索引优化的递归方法：

时间复杂度: 

- **构建哈希表 (`inorder_map`)**: 需要遍历一次 `inorder` 数组，这个过程是 O(N)。
- **递归构建树 (`createTree`)**: 递归函数会为每个节点被调用一次。在每次调用中，所有的操作（从 `postorder` 取值，在哈希表中查找，新建节点）都是 O(1) 的。因为有 N 个节点，所以这部分的总时间是 O(N)。

**总时间复杂度 = O(N)+O(N)=O(N)。**

空间复杂度：

* **递归调用栈 (Recursion Stack)**: 这是你正确分析出的部分。递归的深度取决于树的高度。在最坏的情况下（树退化成一个链表），树的高度 H 等于节点数 N。在最好的情况下（完全平衡的二叉树），高度 H约等于 logN。所以这部分的空间复杂度是 O(H)。

* **哈希表 (`inorder_map`)**: 这是你分析中遗漏的部分。为了实现 O(1) 的查找，我们创建了一个哈希表来存储中序遍历数组中所有元素的值和索引。这个哈希表需要存储 N 个元素，因此它占用的空间是 O(N)。

总的辅助空间复杂度是这两部分之和：

空间复杂度=O(N) (哈希表)+O(H) (递归栈)

因为树的高度 H 总是小于或等于节点数 N (H≤N)，所以在评估整体复杂度时， O(N) 是主导项。

因此，**整体的空间复杂度是 O(N)**。

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for(int i = 0; i < inorder.size(); i++){
            inorder_map[inorder[i]] = i;
        }
        return createTree(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);
    }

private:
    // 需要反复在数组中寻找某一个值的位置时最好使用哈希表。
    unordered_map<int, int> inorder_map;

    // 这种需要递归反复使用数组的题需要传引用和索引要比每次递归新建数组性能好上不少。
    TreeNode* createTree(vector<int>& inorder, vector<int>& postorder,
        int inorder_left, int inorder_right, int postorder_left, int postorder_right){
        // 空节点
        if(inorder_left > inorder_right) return nullptr;
        // 找到后续遍历的最后一个节点
        int root_val = postorder[postorder_right];
        TreeNode* root = new TreeNode(root_val);
        //  找到中序遍历中的位置
        int pos = inorder_map[root_val];
        // 计算左子树的节点数量（方便下一步确定边界）
        int left_num = pos - inorder_left;
        // 左子树右子树递归
        root->left = createTree(inorder, postorder, 
        inorder_left, pos - 1, postorder_left, postorder_left + left_num - 1);
        root->right = createTree(inorder, postorder, 
        pos + 1,  inorder_right, postorder_left + left_num, postorder_right - 1);
        return root;
    }
};
```

举一反三：[105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for(int i = 0; i < inorder.size(); i++){
            map[inorder[i]] = i;
        }
        return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);
    }
 
private:
    unordered_map <int, int> map;
    TreeNode* create(vector<int>& preorder, vector<int>& inorder, 
    int pre_left, int pre_right, int in_left, int in_right){
        if(in_left >　in_right) return nullptr;
        int val = preorder[pre_left];
        TreeNode* node = new TreeNode(val);
        int pos = map[val];
        int left_num = pos - in_left;
        node->left = create(preorder, inorder, pre_left + 1, pre_left + left_num, in_left, pos - 1);
        node->right = create(preorder, inorder, pre_left + left_num + 1, pre_right, pos + 1, in_right);
        return node;
    }
};
```

