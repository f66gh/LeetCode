# 栈和队列

## 理论基础

栈是队列是STL里边的两个数据结构。不同的STL中实现方式不一样。

由于栈必须符合先进后出原则，故栈不提供迭代器，不能遍历所有元素。

栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可拔插的，**我们可以决定使用哪种容器实现栈的功能。**

STL中栈被归类为container adapter（**容器适配器**）。

STL中栈的底层可以是vector,deque,list。默认是deque，**deque是一个双向队列**，只要封住一段，只开通另一端就可以实现栈的逻辑了。

## 用栈实现队列

具体思路：[代码随想录](https://programmercarl.com/0232.用栈实现队列.html#思路)

```cpp
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;
    MyQueue() {
        
    }
    
    void push(int x) {
        stIn.push(x);
    }
    
    int pop() {
        if(stOut.empty()){
            while(!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int res = stOut.top();
        stOut.pop();
        return res;
    }
    
    int peek() {
        // 注意复用
        int res = this->pop();
        stOut.push(res);
        return res;
    }
    
    bool empty() {
        if(stIn.empty() && stOut.empty()) return true;
        return false;
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

## 用队列实现栈

### 双队列法

思路一：让`push()` 操作的时间复杂度为 O(1)。`pop()` 和 `top()` 的时间复杂度为 O(n)。

```cpp
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;

    MyStack() {
        
    }
    
    void push(int x) {
        que1.push(x);
    }
    
    int pop() {
        if(empty()) {} ;
        while(que1.size() > 1){
            que2.push(que1.front());
            que1.pop();
        }
        int res = que1.front();
        que1.pop();
        while(que2.size() > 0) {
            que1.push(que2.front());
            que2.pop();
        }
        return res;
    }
    
    int top() {
        if(empty()) {} ;
        while(que1.size() > 1){
            que2.push(que1.front());
            que1.pop();
        }
        int res = que1.front();
        que2.push(que1.front());
        que1.pop();
        while(que2.size() > 0) {
            que1.push(que2.front());
            que2.pop();
        }
        return res;
    }
    
    bool empty() {
        return que1.size() == 0;
    }
};
```

思路2：`pop()`, `top()` 和 `empty()` 操作的时间复杂度都是 O(1)，因为它们只需要操作 `que1` 的队首元素。缺点是 `push()` 操作的时间复杂度为 O(n)，因为每次都要移动所有元素。

```cpp
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;

    MyStack() {
        
    }
    
    void push(int x) {
        que2.push(x);
        while(que1.size() > 0){
            que2.push(que1.front());
            que1.pop();
        }
        std::swap(que1, que2);
    }
    
    int pop() {
        int res = que1.front();
        que1.pop();
        return res;
    }
    
    int top() {
        return que1.front();
    }
    
    bool empty() {
        return que1.size() == 0;
    }
};
```

### 单队列法

每次要弹出或者获取栈顶元素只需要将队列中的前size()-1个元素挪到第一个元素后就行。

`push()`和 `empty()` 操作的时间复杂度都是 O(1)。缺点是 `pop()` 和`top()`操作的时间复杂度为 O(n)，因为每次都要移动所有元素。

```cpp
class MyStack {
public:
    queue<int> que1;

    MyStack() {
        
    }
    
    void push(int x) {
        que1.push(x);
    }

    int circle(){
        int len = que1.size();
        while(len > 1){
            int x = que1.front();
            que1.pop();
            que1.push(x);
            len--;
        }
        int x = que1.front();
        que1.pop();
        return x;
    }
    
    int pop() {
        return circle();
    }
    
    int top() {
        int x = circle();
        que1.push(x);
        return x;
    }
    
    bool empty() {
        return que1.size() == 0;
    }
};
```

## 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

一共有三种情况

![20.有效括号](./pic/20.有效括号.gif)

自己写的依托：

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(int i = 0; i < s.size(); i++){
            if(s[i] == ')'){
                if(st.empty()){
                    return false;
                }
                if(st.top() == '('){
                    st.pop();
                } 
                else {
                    if(st.top() == '[' || st.top() == '{'){
                        return false;
                    }
                    st.push(s[i]);
                }
            }
            else if(s[i] == '}'){
                if(st.empty()){
                    return false;
                }
                if(st.top() == '{'){
                    st.pop();
                } 
                else {
                    if(st.top() == '[' || st.top() == '('){
                        return false;
                    }
                    st.push(s[i]);
                }
            }
            else if(s[i] == ']'){
                if(st.empty()){
                    return false;
                }
                if(st.top() == '['){
                    st.pop();
                } 
                else {
                    if(st.top() == '{' || st.top() == '('){
                        return false;
                    }
                    st.push(s[i]);
                }
            }
            else {
                st.push(s[i]);
            }
        }
        return st.empty();
    }
};
```

优化1：可以用哈希表做

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        unordered_map<char, char> m = {
            {')', '('}, {'}', '{'}, {']', '['}
        };
        for(char c : s){
            if(m.count(c)) {
                if(st.empty()) return false;
                if(st.top() != m[c]) {
                    return false;
                }
                st.pop();
            }
            else {
                st.push(c);
            }
        }

        return st.empty();
    }
};
```

优化2：不用哈希表

懒得写了。

## 逆波兰表达式求值

[150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

正确的算法非常简单，只需要一个栈就够了：

1. 创建一个**栈**，用于存放数字（操作数）。
2. **遍历**输入的字符串数组中的每一个元素。
3. 对于每一个元素：
   - 如果它是**数字**，将其转换成整数并**压入栈中**。
   - 如果它是**运算符**（`+`, `-`, `*`, `/`），则**连续两次从栈中弹出**两个数字。注意弹出的顺序：第一个弹出的是**第二个操作数**，第二个弹出的是**第一个操作数**。
   - 执行运算（第一个操作数 运算符 第二个操作数）。
   - 将运算结果**压回栈中**。
4. 遍历结束后，栈中唯一剩下的那个数字就是整个表达式的结果。

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for(string s : tokens){
            if(s == "+" || s == "-" || s == "*" || s == "/") {
                int i = st.top();
                st.pop();
                int j = st.top();
                st.pop();
                if(s == "+") st.push(i + j);
                else if(s == "-") st.push(j - i);
                else if(s == "*") st.push(j * i);
                else st.push(j / i);
            }
            else {
                st.push(stoll(s));
            }
        }
        return st.top();
    }
};
```

## 滑动窗口最大值

[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/)

这个解法的核心思想是，**在滑动窗口移动的过程中，维护一个双端队列，使得队列中存储的元素下标对应的数值是单调递减的。**

下面是具体的实现步骤：

1. **初始化**：创建一个双端队列 `deque`，用来存储数组元素的**下标**。同时，创建一个结果数组 `result`。
2. **遍历数组**：遍历输入数组 `nums`，用一个变量 `i` 追踪当前元素的下标。
3. **维护单调性**：
   - 在将 `i` 加入队列之前，从队列的尾部开始，移除所有下标 `j`，使得 `nums[j]` 小于或等于 `nums[i]`。这样做是为了保证队列中元素的单调递减性质。如果新元素 `nums[i]` 比队列尾部的元素大，那么队列尾部的元素就不可能成为未来任何一个窗口的最大值，因为 `nums[i]` 在它之后，并且比它大。
   - 将当前下标 `i` 添加到队列的尾部。
4. **移除过期下标**：
   - 检查队列头部的下标是否在当前窗口内。当前窗口的左边界是 `i - k + 1`。如果队列头部的下标 `deque.front()` 小于 `i - k + 1`，说明这个下标已经超出了滑动窗口的范围，需要将其从队列头部移除。
5. **记录最大值**：
   - 当 `i` 大于等于 `k-1` 时，说明当前窗口已经形成，此时队列头部的元素就是当前窗口的最大值。将 `nums[deque.front()]` 加入结果数组 `result`。

时间复杂度：O(n)，其中 n 是数组 nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)。

空间复杂度：O(k)。「不断从队首弹出元素」保证了队列中最多不会有超过 k+1 个元素，因此队列使用的空间为 O(k)。

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;
        vector<int> res;
        for(int i = 0; i < nums.size(); i++){
            // 1. 移除队列中过期的下标
            if(!dq.empty() && i - k == dq.front()) dq.pop_front();
            // 2. 维护单调性
            while(!dq.empty() && nums[i] > nums[dq.back()]) dq.pop_back();
            // 3. 将当前元素的下标加入队尾
            dq.push_back(i);
            // 4. 当窗口形成时，将最大值（即队头元素）加入结果集
            if(i >= k - 1) {
                res.push_back(nums[dq.front()]);
            }

        }
        return res;
    }
};
```

