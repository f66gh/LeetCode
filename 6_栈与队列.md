# 栈和队列

## 理论基础

栈是队列是STL里边的两个数据结构。不同的STL中实现方式不一样。

由于栈必须符合先进后出原则，故栈不提供迭代器，不能遍历所有元素。

栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可拔插的，**我们可以决定使用哪种容器实现栈的功能。**

STL中栈被归类为container adapter（**容器适配器**）。

STL中栈的底层可以是vector,deque,list。默认是deque，**deque是一个双向队列**，只要封住一段，只开通另一端就可以实现栈的逻辑了。

## 用栈实现队列

具体思路：[代码随想录](https://programmercarl.com/0232.用栈实现队列.html#思路)

```cpp
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;
    MyQueue() {
        
    }
    
    void push(int x) {
        stIn.push(x);
    }
    
    int pop() {
        if(stOut.empty()){
            while(!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int res = stOut.top();
        stOut.pop();
        return res;
    }
    
    int peek() {
        // 注意复用
        int res = this->pop();
        stOut.push(res);
        return res;
    }
    
    bool empty() {
        if(stIn.empty() && stOut.empty()) return true;
        return false;
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

## 用队列实现栈

### 双队列法

思路一：让`push()` 操作的时间复杂度为 O(1)。`pop()` 和 `top()` 的时间复杂度为 O(n)。

```cpp
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;

    MyStack() {
        
    }
    
    void push(int x) {
        que1.push(x);
    }
    
    int pop() {
        if(empty()) {} ;
        while(que1.size() > 1){
            que2.push(que1.front());
            que1.pop();
        }
        int res = que1.front();
        que1.pop();
        while(que2.size() > 0) {
            que1.push(que2.front());
            que2.pop();
        }
        return res;
    }
    
    int top() {
        if(empty()) {} ;
        while(que1.size() > 1){
            que2.push(que1.front());
            que1.pop();
        }
        int res = que1.front();
        que2.push(que1.front());
        que1.pop();
        while(que2.size() > 0) {
            que1.push(que2.front());
            que2.pop();
        }
        return res;
    }
    
    bool empty() {
        return que1.size() == 0;
    }
};
```

思路2：`pop()`, `top()` 和 `empty()` 操作的时间复杂度都是 O(1)，因为它们只需要操作 `que1` 的队首元素。缺点是 `push()` 操作的时间复杂度为 O(n)，因为每次都要移动所有元素。

```cpp
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;

    MyStack() {
        
    }
    
    void push(int x) {
        que2.push(x);
        while(que1.size() > 0){
            que2.push(que1.front());
            que1.pop();
        }
        std::swap(que1, que2);
    }
    
    int pop() {
        int res = que1.front();
        que1.pop();
        return res;
    }
    
    int top() {
        return que1.front();
    }
    
    bool empty() {
        return que1.size() == 0;
    }
};
```

### 单队列法

每次要弹出或者获取栈顶元素只需要将队列中的前size()-1个元素挪到第一个元素后就行。

`push()`和 `empty()` 操作的时间复杂度都是 O(1)。缺点是 `pop()` 和`top()`操作的时间复杂度为 O(n)，因为每次都要移动所有元素。

```cpp
class MyStack {
public:
    queue<int> que1;

    MyStack() {
        
    }
    
    void push(int x) {
        que1.push(x);
    }

    int circle(){
        int len = que1.size();
        while(len > 1){
            int x = que1.front();
            que1.pop();
            que1.push(x);
            len--;
        }
        int x = que1.front();
        que1.pop();
        return x;
    }
    
    int pop() {
        return circle();
    }
    
    int top() {
        int x = circle();
        que1.push(x);
        return x;
    }
    
    bool empty() {
        return que1.size() == 0;
    }
};
```

## 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

一共有三种情况

![20.有效括号](./pic/20.有效括号.gif)

自己写的依托：

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(int i = 0; i < s.size(); i++){
            if(s[i] == ')'){
                if(st.empty()){
                    return false;
                }
                if(st.top() == '('){
                    st.pop();
                } 
                else {
                    if(st.top() == '[' || st.top() == '{'){
                        return false;
                    }
                    st.push(s[i]);
                }
            }
            else if(s[i] == '}'){
                if(st.empty()){
                    return false;
                }
                if(st.top() == '{'){
                    st.pop();
                } 
                else {
                    if(st.top() == '[' || st.top() == '('){
                        return false;
                    }
                    st.push(s[i]);
                }
            }
            else if(s[i] == ']'){
                if(st.empty()){
                    return false;
                }
                if(st.top() == '['){
                    st.pop();
                } 
                else {
                    if(st.top() == '{' || st.top() == '('){
                        return false;
                    }
                    st.push(s[i]);
                }
            }
            else {
                st.push(s[i]);
            }
        }
        return st.empty();
    }
};
```

优化1：可以用哈希表做

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        unordered_map<char, char> m = {
            {')', '('}, {'}', '{'}, {']', '['}
        };
        for(char c : s){
            if(m.count(c)) {
                if(st.empty()) return false;
                if(st.top() != m[c]) {
                    return false;
                }
                st.pop();
            }
            else {
                st.push(c);
            }
        }

        return st.empty();
    }
};
```

优化2：不用哈希表

懒得写了。

## 逆波兰表达式求值

[150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

正确的算法非常简单，只需要一个栈就够了：

1. 创建一个**栈**，用于存放数字（操作数）。
2. **遍历**输入的字符串数组中的每一个元素。
3. 对于每一个元素：
   - 如果它是**数字**，将其转换成整数并**压入栈中**。
   - 如果它是**运算符**（`+`, `-`, `*`, `/`），则**连续两次从栈中弹出**两个数字。注意弹出的顺序：第一个弹出的是**第二个操作数**，第二个弹出的是**第一个操作数**。
   - 执行运算（第一个操作数 运算符 第二个操作数）。
   - 将运算结果**压回栈中**。
4. 遍历结束后，栈中唯一剩下的那个数字就是整个表达式的结果。

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for(string s : tokens){
            if(s == "+" || s == "-" || s == "*" || s == "/") {
                int i = st.top();
                st.pop();
                int j = st.top();
                st.pop();
                if(s == "+") st.push(i + j);
                else if(s == "-") st.push(j - i);
                else if(s == "*") st.push(j * i);
                else st.push(j / i);
            }
            else {
                st.push(stoll(s));
            }
        }
        return st.top();
    }
};
```

