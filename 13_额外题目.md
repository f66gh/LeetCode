# 13_额外题目

[1365. 有多少小于当前数字的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/description/)

时间复杂度O(nlogn)做法

```cpp
class Solution {
public:
    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
        int n = nums.size();
        // 保留初始数据用于查表
        vector<int> vec = nums;
        // 巧妙的O(nlogn)做法，先排序
        sort(vec.begin(), vec.end());
        // 用hash倒序遍历，存储元素第一次出现的位置（就是排序答案）
        int hash[101];
        for(int i = n - 1; i >= 0; i--){
            hash[vec[i]] = i;
        }
        // 在 C++ 中，如果需要动态长度的数组，应该使用 std::vector。它会自动管理内存，且符合 C++ 标准。
        vector<int> res;
        for(int i = 0; i < n; i++){
            res.push_back(hash[nums[i]]);
        }
        return res;
    }
};
```

[941. 有效的山脉数组 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-mountain-array/description/)

```cpp
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        if(arr.size() < 3) return false;
        // 双指针
        int i = 0, j = arr.size() - 1;
        while(i != arr.size() - 2){
            if(arr[i + 1] > arr[i]) i++;
            else break;
        }
        while(j != 1){
            if(arr[j - 1] > arr[j]) j--;
            else break;
        }
        if(i == j) return true;
        return false;
    }
};
```

[1207. 独一无二的出现次数 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-number-of-occurrences/description/)

其实用一步哈希和一步set时间复杂度是O(n)

```cpp
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        int n = arr.size();
        sort(arr.begin(), arr.end());
        unordered_set<int> uset;
        int i = 0, j = 0;
        while(i != n - 1){
            if(arr[i] != arr[i + 1]) {
                if(!uset.count(j - i + 1)) uset.insert(j - i + 1);
                else return false;
                j = i + 1;
            }
            i++;
            // 判断最后一个数
            if(i == n - 1){
                if(!uset.count(j - i + 1)) return true;
                else return false;
            }
        }
        
        return true;
    }
};
```

[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
滑动窗口

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 哈希表退化为数组
        vector<int> umap(128, 0);
        // 滑动窗口
        int n = s.size();
        int max_length = 0;
        for(int i = 0, j = 0; i < n; i++){
            umap[s[i]]++;
            if(umap[s[i]] != 1) {
                while(umap[s[i]] != 1){
                    umap[s[j]]--;
                    j++;
                }
            }
            max_length = max(max_length, i - j + 1);
        }
        return max_length;
    }
};
```

[76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/)

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        int min_start = 0; // 最小滑动窗口的起点
        int min_length = INT_MAX; // 最小滑动窗口的长度
        int m = s.size(), n = t.size();
        int left_num = n; // 是否存在被涵盖的字母个数（保持大于等于0）
        vector<int> umap(128, 0); // ASCII一共才128个
        // 初始化数组
        for(int i = 0; i < n; i++){
            umap[t[i]]++;
        }
        for(int i = 0, j = 0; i < m; i++){
            umap[s[i]]--;
            // 只有不多余的字母才能改变计数，而哈希表中的数可以为负数
            if(umap[s[i]] >= 0) left_num--; 
            while(left_num == 0){
                if(umap[s[j]] >= 0) left_num++;
                umap[s[j]]++;

                if(i - j + 1 < min_length){
                    min_start = j;
                    min_length = i - j + 1;
                }
                
                j++;
            }
        }
        if(min_length != INT_MAX) return s.substr(min_start, min_length);
        return "";
    }
};
```

[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/)

前缀和+哈希表

非常巧妙的做法

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> umap;
        
        int n = nums.size();
        vector<int> pre_sum(n, 0);
        umap[0] = 1; // 和为 0 的前缀和出现过 1 次（即数组一开始之前的空前缀）。
        pre_sum[0] = nums[0];
        // 求res必须和哈希表的更新放在一块，要不就错了
        int res = 0;
        for(int i = 0; i < n; i++) {
            if(i != 0) pre_sum[i] = pre_sum[i - 1] + nums[i];
            res += umap[pre_sum[i] - k];
            umap[pre_sum[i]]++;
        }

        return res;
    }
};
```

更优雅的做法

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> umap;
        
        int n = nums.size();
        int pre_sum = 0;
        umap[0] = 1; // 和为 0 的前缀和出现过 1 次（即数组一开始之前的空前缀）。

        umap.reserve(nums.size()); // 如果你知道数据量很大，可以减少哈希表自动扩容（Rehash）的次数，这在 C++ 中是一个常见的常数级优化。

        // 求res必须和哈希表的更新放在一块，要不就错了
        int res = 0;
        for(int i = 0; i < n; i++) {
            pre_sum += nums[i];
            // 这样先判断是否存在性能更好一点
            if (umap.count(pre_sum - k)) res += umap[pre_sum - k]; 
            umap[pre_sum]++;
        }

        return res;
    }
};
```

