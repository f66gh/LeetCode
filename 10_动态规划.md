#  10_动态规划

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

动规是由前一个状态推导出来的，而贪心是局部直接选最优的

**核心思想就是“用空间换时间”**，把计算过的结果存起来，避免重复计算。

## 基础题目

递归法：

```cpp
class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1 || n == 2) return 1;
        return fib(n - 1) + fib(n - 2);
    }
};
```

动态规划，自底向下

```cpp
class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;

        // 初始化一个数组，能存放下f(0)到f(n)的数
        vector<int> dp(n + 1);

        // 边界初始化
        dp[0] = 0;
        dp[1] = 1;

        // 递归式
        for(int i = 2; i < n + 1; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
};
```

记忆化搜索，自顶向下

```cpp
class Solution {
public:
    int fib(int n) {
         memo.assign(n + 1, -1);
         return dp(n);
    }
private:
    vector<int> memo;
    int dp(int n){
        if (n == 0) return 0;
        if (n == 1) return 1;

        // 检查备忘录
        if (memo[n] != -1) return memo[n]; 

        // 没看过
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
};
```

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)

暴力解法，超时

```cpp
class Solution {
public:
    int climbStairs(int n) {
        dp(n);
        return res;
    }
private:
    int res = 0;
    void dp(int n){
        if(n == 1){
            res++;
            return;
        }
        if(n == 2) res++;
        if(n <= 0) return;
        dp(n - 1);
        dp(n - 2);
        return;
    }
};
```

自底向上，表格法 (Tabulation)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        // dp是方法数
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2; //走到第二个台阶有两种方法
        // 对于台阶N，由于只能从n-1走1个阶或者从n-2走两个阶上来，故可列状态转移方程
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

自底向上的优化方法

在计算 `dp[i]` 时，你其实**只用到了 `dp[i-1]` 和 `dp[i-2]`**。你不需要存储整个数组。

我们可以只用两个变量来保存前两个状态，这叫做“滚动数组”思想，把空间复杂度从 $O(n)$ 降到了 $O(1)$。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        int prev_1 = 1;
        int prev_2 = 2; //走到第二个台阶有两种方法
        int cur = 0;
        // 对于台阶N，由于只能从n-1走1个阶或者从n-2走两个阶上来，故可列状态转移方程
        for(int i = 3; i <= n; i++){
            cur = prev_1 + prev_2;
            prev_1 = prev_2;
            prev_2 = cur;
        }
        return cur;
    }
};
```



自顶向下，备忘录法

```cpp
class Solution {
public:
    int climbStairs(int n) {
        memo.assign(n + 1, 0);
        return dp(n);
    }
private:
    vector<int> memo;

    int dp(int n){
        if(n <= 2) return n;
        if(memo[n] != 0) return memo[n];
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
};
```

[746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/submissions/675306280/)

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // 和爬楼梯类似，我们需要给每一个台阶都找一个最小爬上来的代价
        int n = cost.size();
        // 注意这里到达第零个台阶和第一个台阶的花费都是0
        int prev_1 = 0;
        int prev_2 = 0;
        int cur = 0;

        for(int i = 2; i <= n; i++){
            // 注意看好步数和从哪个台阶上的，prev_1表示到达上上的台阶的花费，Prev_2表示到达上个台阶的花费
            cur = min(prev_1 + cost[i - 2], prev_2 + cost[i - 1]);
            prev_1 = prev_2;
            prev_2 = cur;
        }

        return cur;
    }
};
```

[63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/description/)

我们要计算到达每个格子的**不同路径数量**。根据题意，要想到达 `(i, j)` 这个格子，机器人只能从它的**上方** `(i-1, j)` 或者**左方** `(i, j-1)` 过来。

因此，**“到达 `(i, j)` 的路径数”** 就等于 **“到达 `(i-1, j)` 的路径数”** 加上 **“到达 `(i, j-1)` 的路径数”**。

这就是动态规划的核心——把一个大问题（到达右下角）分解为一堆相关联的小问题（到达每一个中间格子）。



自底向上，时间复杂度是 $O(m \times n)$，空间复杂度是 $O(m \times n)$。

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        // 如果左上角没有障碍物再初始化
        if(obstacleGrid[0][0] != 1) dp[0][0] = 1;
        else return 0;

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i == 0 && j == 0) continue;
                // 遇到障碍物
                if(obstacleGrid[i][j] == 1) continue;
                if(i == 0) dp[i][j] = dp[i][j - 1];
                else if(j == 0) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
            }
        }

        return dp[m - 1][n - 1];
    }
};
```

滚动数组

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        // 压缩空间，用滚动数组法，设置上一行为记忆数组
        vector<int> dp(n, 0);
        // 如果左上角和右下角没有障碍物再初始化
        if(obstacleGrid[0][0] != 1) dp[0] = 1;
        else return 0;

        // 初始化第一行记忆数组
        for(int i = 1; i < n; i++){
            // 如果当前是障碍物则直接设为0
            if(obstacleGrid[0][i] != 1) dp[i] = dp[i - 1];
        }

        // 直接从第二行开始遍历
        for(int i = 1; i < m; i++){
            for(int j = 0; j < n; j++){
                // 遇到障碍物
                if(obstacleGrid[i][j] == 1) dp[j] = 0;
                else if(j == 0) ;
                else dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
```

[343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/description/)

- 时间复杂度：O(n^2)
- 空间复杂度：O(n)

```cpp
class Solution {
public:
    int integerBreak(int n) {
        // 核心思想：每个数切了一刀之后，可以拆分为两个数，这两个数要比较自己还是自己的最大乘积谁更大
        vector<int> dp(n + 1, 0);
        if(n == 2) return 1;
        if(n == 3) return 2;
        dp[2] = 1;
        for(int i = 3; i <= n; i++){
            for(int j = 1; j <= i / 2; j++){
                int k = i - j;
                int factor_1 = max(j, dp[j]);
                int factor_2 = max(k, dp[k]);
                dp[i] = max(dp[i], factor_1 * factor_2);
            }
        }
        return dp[n];
    }
};
```

[96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/description/)

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        // 这里的i是有多少个节点
        for(int i = 2; i <= n; i++){
            // 这里的j是以j为根节点
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

## 0-1背包问题

`dp` 数组的定义（里面存什么）完全取决于“问题要求什么”。

| **问题类型**             | **题目范例**                           | **问题“求什么”？**                                       | **dp[j] 的定义 (灵魂)**                                | **递推公式 (骨架)**                                          |
| ------------------------ | -------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 求最大价值**        | **416. 分割子集**   **1049. 石头重量** | "在容量 `j` 下，能装的**最大重量(价值)是多少**？"        | `dp[j]` = 容量为 `j` 时，能装的**最大重量**。          | `dp[j] = max(dp[j], dp[j-w] + v)`   (这里 `v` = `w`)         |
| **2. 求组合数**          | **494. 目标和**                        | "要装满容量 `j`，一共有**多少种方法**？"                 | `dp[j]` = 装满容量 `j` 的**方法总数**。                | `dp[j] = dp[j] + dp[j-w]`   (方法数 = 不放的方法 + 放的方法) |
| **3. 求最大价值 (变种)** | **474. 一和零 (本题)**                 | "在容量 `(j, k)` 下，能装的**最多物品数(长度)是多少**？" | `dp[j][k]` = 容量为 `j,k` 时，能装的**最大子集长度**。 | `dp[j][k] = max(dp[j][k], 1 + dp[j-z][k-o])`                 |

[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

0-1背包解法

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // 将问题转化为能否从Nums中调出nums/2的元素使得其和等于Nums的和
        int n = nums.size();
        int sum = 0;
        for(int i = 0; i < n; i++){
            sum += nums[i];
        }
        if(sum % 2 != 0) return false;
        int half = sum / 2;
        
        vector<vector<int>> dp(n, vector<int>(half + 1, 0));
        // 初始化第一行（物品0）
        for(int i = nums[0]; i <= half; i++){
            dp[0][i] = nums[0];
        }

        // 填充背包,从第二行开始填,i是物品
        for(int i = 1; i < n; i++){
            for(int j = 1; j <= half; j++){
                // 和上行一样
                if(nums[i] > j) dp[i][j] = dp[i - 1][j];
                // 判断谁更大
                else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);
            }
            // 判断当前物品行最后一格是否为half
            if(dp[i][half] == half) return true;
        }
        return false;
    }
};
```

滚动数组法

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // 将问题转化为能否从Nums中调出nums/2的元素使得其和等于Nums的和
        int n = nums.size();
        int sum = 0;
        for(int i = 0; i < n; i++){
            sum += nums[i];
        }
        if(sum % 2 != 0) return false;
        int half = sum / 2;
        
        // 滚动数组优化方法：由于第i行只需要第i-1行的数据
        vector<int> dp(half + 1);
        // 初始化第一行（物品0）
        for(int i = nums[0]; i <= half; i++){
            dp[i] = nums[0];
        }

        // 填充背包,从第二行开始填,i是物品
        for(int i = 1; i < n; i++){
            // 注意必须是倒序遍历容量
            for(int j = half; j >= 1; j--){
                // 和上行一样，不用动了
                if(nums[i] > j) ;
                // 判断谁更大
                else dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
            // 判断当前物品行最后一格是否为half
            if(dp[half] == half) return true;
        }
        return false;
    }
};
```

[1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/description/)

写法更优雅的滚动数组法

```cpp
class Solution {
public:
    // 核心思想：把石头分成重量最近的两堆
    // 从 stones 数组中挑选任意石头，在总重量不超过 sum / 2 的前提下，能达到的最大总重量是多少？
    int lastStoneWeightII(vector<int>& stones) {
        int n = stones.size();
        int sum = 0;
        for(int s : stones) sum += s;
        int half = sum / 2;
        vector<int> dp(half + 1, 0);
        // 不用初始化第一行了，在正常遍历中能够正确填充第一行
        for(int i = 0; i < n; i++){
            for(int j = half; j >= stones[i]; j--){
                dp[j] = max(dp[j], stones[i] + dp[j - stones[i]]);
            }
            // 不需要额外设置变量存储最大值，因为dp[half]已经经过Max筛选了
        }
        return sum - 2 * dp[half];
    }
};
```

[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/description/)

0-1背包组合问题写法

```cpp
class Solution {
public:
    // 转化为背包问题，找到sum + target / 2 的值就好
    int findTargetSumWays(vector<int>& nums, int target) {
        // 这道题和之前dp里边填重量不同，而是填装满这个背包的方法有多少种（组合问题）
        int sum = 0;
        int zeroNum = 0;
        for(int n : nums) {
            sum += n;
            // 需要用到0的个数
            if(n == 0) zeroNum++;
        }
        if(sum < abs(target)) return 0;
        if((sum + target) % 2 == 1) return 0;
        int half = (sum + target) / 2;
        int n = nums.size();
        // 滚动数组
        vector<int> dp(half + 1, 0);
        // 初始化第一行第一列，和正常的二维数组有区别
        dp[0] = 1;
        // 也不用初始化第一行
        // if(nums[0] != 0 && nums[0] <= half) dp[nums[0]] = 1;

        for(int i = 0; i < n; i++){
            for(int j = half; j >= nums[i]; j--){
                // 组合写法
                dp[j] = dp[j] + dp[j - nums[i]];
            }
        }
        return dp[half];
    }
};
```

[474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/description/)

这道题背的答案，太恶心了。

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(string s : strs){
            int zero = 0;
            int one = 0;
            for(char c : s){
                if(c == '0') zero++;
                else one++;
            }
            for(int i = m; i >= zero; i--){
                for(int j = n; j >= one; j--){
                    dp[i][j] = max(dp[i][j], 1 + dp[i - zero][j - one]);
                }
            }
        }
        return dp[m][n];
    }
};
```

## 完全背包问题

[518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/description/)

完全背包问题，求组合数

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        // 完全背包算法，i为使用的硬币种类，j为总金额
        int n = coins.size();
        vector<vector<unsigned long long>> dp(n, vector<unsigned long long>(amount + 1, 0));
        // 初始化数组
        dp[0][0] = 1;
        for(int i = 1; i <= amount; i++){
            if(i % coins[0] == 0) dp[0][i] = 1;
        }

        for(int i = 1; i < n; i++){
            dp[i][0] = 1; 
            for(int j = 1; j <= amount; j++){
                if(j < coins[i]) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]];
            }
        }

        return (int) dp[n - 1][amount];
    }
};
```

滚动数组优化

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        // 完全背包算法，i为使用的硬币种类，j为总金额
        int n = coins.size();
        vector<unsigned long long> dp(amount + 1, 0);
        // 初始化数组
        dp[0] = 1;

        for(int c : coins){
            for(int j = c; j <= amount; j++){
                dp[j] = dp[j] + dp[j - c];
            }
        }

        return (int) dp[amount];
    }
};
```

[377. 组合总和 Ⅳ - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iv/description/)

这道题是求的排列数

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        // 我们只关注插入的最后一个数
        vector<unsigned long long> dp(target + 1, 0);
        dp[0] = 1;
        for(int i = 1; i <= target; i++){
            for(int n : nums){
                if(i >= n) dp[i] += dp[i - n];
            }
        }
        return (int) dp[target];
    }
};
```

[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/description/)

自己写的依托：

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 这道题我的思路是外层遍历amount，dp里边填用到几个数
        // 感觉像是完全背包排列问题的变种
        if(amount == 0) return 0;
        vector<int> dp(amount + 1, -1);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(int j = 0; j < coins.size(); j++){
                if(i >= coins[j] && dp[i - coins[j]] != -1) {
                    if(dp[i] != -1) dp[i] = min(dp[i - coins[j]] + 1, dp[i]);
                    else dp[i] = dp[i - coins[j]] + 1;
                }
            }
        }
        return dp[amount];
    }
};
```

优化版，利用“哨兵”解决未被更新过的dp值。而且这道题不是组合/排序类问题，只是最大最小值问题，不需要给内外层循环定死。

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if(amount == 0) return 0;
        // 最多只有amount个1硬币，设置上限
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;
        for(int i = 0; i < coins.size(); i++){
            for(int j = 0; j <= amount; j++){
                if(j >= coins[i]) {
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
};
```

[279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/)

传统派写法：

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> vec;
        check(vec, n);
        vector<int> dp(n + 1, n + 1);
        dp[0] = 0;
        for(int i = 0; i < vec.size(); i++){
            for(int j = 0; j <= n; j++){
                if(j >= vec[i]) {
                    dp[j] = min(dp[j - vec[i]] + 1, dp[j]);
                }
            }
        }
        return dp[n];
    }
private:
    void check(vector<int>& vec, int n){
        for(int i = 1; i <= n; i++){
            int k = (int) sqrt(i);
            if(k * k == i) vec.push_back(i);
        }
    }
};
```

维新派写法：

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, n + 1);
        dp[0] = 0;
        for(int i = 1; i * i <= n; i++){
            int square = i * i;
            for(int j = square; j <= n; j++){
                if(j >= square) {
                    dp[j] = min(dp[j - square] + 1, dp[j]);
                }
            }
        }
        return dp[n];
    }
};
```

[139. 单词拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/word-break/description/)

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        // 本质是一个多重背包排序问题，外层循环s
        int n = s.size();
        vector<bool> dp(n + 1, false);
        dp[0] = true;
        for(int i = 1; i <= n; i++){
            for(string word : wordDict){
                // 如果已经要检查的字符串长度大于要比对的单词
                int w = word.size();
                if(i >= w){
                    // 当上一个是true且单词能匹配上时
                    if(dp[i - w] == true && s.substr(i - w, w) == word){
                        // 不用比对了，直接检查下一个字符串的匹配性
                        dp[i] = true;
                        break;
                    }
                }
            }
        }
        return dp[n];
    }
};
```

## 打家劫舍

普通版：

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // 这里的dp是偷到第几间房子的最大盗窃值
        int n = nums.size();
        vector<int> dp(n + 1, 0);
        dp[1] = nums[0];
        for(int i = 2; i <= n; i++){
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]);
        }
        return dp[n];
    }
};
```

空间压缩：

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // 空间压缩
        int n = nums.size();
        if(n == 1) return nums[0];
        int pre = nums[0];
        int cur = max(nums[0], nums[1]);
        for(int i = 2; i < n; i++){
            int temp = cur;
            cur = max(cur, pre + nums[i]);
            pre = temp;
        }
        return cur;
    }
};
```

[213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/description/)

成环，分类讨论

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return nums[0];
        vector<int> dp1(n, 0); // 不带头情况
        vector<int> dp2(n, 0); // 不带尾情况
        dp1[1] = nums[1];
        dp2[1] = nums[0];
        for(int i = 2; i < n; i++){
            dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);
            dp2[i] = max(dp2[i - 1], dp2[i - 2] + nums[i - 1]);
        }
        return max(dp1[n - 1], dp2[n - 1]);
    }
};
```

[337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/description/)

树形dp入门，后序遍历返回的是一组数或者一个数。

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> res = robTree(root);
        return max(res[0], res[1]);
    }
private:
    vector<int> robTree(TreeNode* root){
        // 如果是空节点
        if(root == nullptr) return {0, 0};

        // 后序遍历
        vector<int> left = robTree(root->left);
        vector<int> right = robTree(root->right);

        // 如果偷这个节点
        int rob_this = root->val + left[1] + right[1];
        // 如果不偷这个节点
        int not_bot_this = max(left[0], left[1]) + max(right[0], right[1]);

        return {rob_this, not_bot_this};
    }
};
```

## 买卖股票

[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

一维数组写法

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<int> dp(n, 0);
        int min = prices[0];
        for(int i = 1; i < n; i++){
            if(prices[i] < min) min = prices[i];
            dp[i] = max(prices[i] - min, dp[i - 1]);
        }
        return dp[n - 1];
    }
};
```

滚动数组写法，和贪心写法是一样的。

到了第i天我只关心两件事：今天股票是否为历史最低价以及今天卖出股票是否赚的最多

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int profit = 0;
        int min_price = prices[0];
        for(int i = 1; i < n; i++){
            min_price = min(prices[i], min_price);
            profit = max(prices[i] - min_price, profit);
        }
        return profit;
    }
};
```

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

之前用的贪心做的，这次用标准的状态机DP做的。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][1] = -prices[0];
        for(int i = 1; i < n; i++){
            // 今天不持有股票
            dp[i][0] = max(dp[i - 1][0] , dp[i - 1][1] + prices[i]);
            // 今天持有
            dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
        }
        return dp[n - 1][0];
    }
};
```

[123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

这道题太tm抽象了，需要用到两个股票的状态

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // 用四种状态，分别是第一个股票持股不持股，第二个股票同理
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] = -prices[0];
        dp[0][2] = -prices[0];
        for(int i = 1; i < n; i++){
            // 第一只股票持股（有两个来源：昨天持股以及今天刚买，第一只股票买的时候自然利润是负数）
            dp[i][0] = max(dp[i - 1][0], -prices[i]); 
            // 第一只股票不持股（有两个来源：昨天没持股以及今天刚卖）
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
            // 第二只股票持股（有两个来源：昨天持股以及今天刚买，第二只股票买的时候注意要用第一只股票的利润计算）
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] - prices[i]);
            // 第二只股票不持股
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] + prices[i]);
        }
        // 第二只股票不持股的状态已经包含了第一只股票的利润
        return dp[n - 1][3];
    }
};
```

滚动数组法

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // 滚动数组
        int buy1 = -prices[0], sell1 = 0;
        int buy2 = -prices[0], sell2 = 0;
        // 注意应该倒序更新，因为四行代码都需要用到上一行被更新的变量（不能用更新后的）
        for(int i = 1; i < n; i++){
            // 第二只股票不持股
            sell2 = max(sell2, buy2 + prices[i]);
            // 第二只股票持股（有两个来源：昨天持股以及今天刚买，第二只股票买的时候注意要用第一只股票的利润计算）
            buy2 = max(buy2, sell1 - prices[i]);
            // 第一只股票不持股（有两个来源：昨天没持股以及今天刚卖）
            sell1 = max(sell1, buy1 + prices[i]);
            // 第一只股票持股（有两个来源：昨天持股以及今天刚买，第一只股票买的时候自然利润是负数）
            buy1 = max(buy1, -prices[i]); 
        }
        return sell2;
    }
};
```

[188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

滚动数组法

注意在初始化时候给所有卖出股票的利润都设为-prices[0]是偷懒行为，应该把除了第一只股票的利润设置为很小的值

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        // 按上题的滚动数组做，这一题的dp是存的第i只股票的状态
        vector<vector<int>> dp(k, vector<int>(2, 0));
        // 初始化：dp[i][0]是不持有，dp[i][1]是持有
        for(int i = 0; i < k; i++) dp[i][1] = -prices[0];
        // 倒序更新避免数据污染
        for(int i = 1; i < n; i++){
            // 除了第一只股票的状态更新
            for(int j = k - 1; j >= 1; j--){
                dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]);
                dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]);
            }
            // 第一只股票状态更新
            dp[0][0] = max(dp[0][0], dp[0][1] + prices[i]);
            dp[0][1] = max(dp[0][1], - prices[i]);
        }

        return dp[k - 1][0];
    }
};
```

 [买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // 不持有要分为两种状态，一种是昨天持有今天卖了（在冷冻期），一种是昨天不持有且不在冷冻期今天不买
        vector<vector<int>> dp(n, vector<int>(3, 0));
        // dp[i][0]是持有
        dp[0][0] = -prices[0];
        for(int i = 1; i < n; i++){
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
            // 昨天持有今天卖了(今天是冷静期)
            dp[i][1] = dp[i - 1][0] + prices[i];
            // 昨天没持有或冷静期今天不买（不在冷静期）
            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]);
        }
        return max(dp[n - 1][1], dp[n - 1][2]);
    }
};
```

[714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();

        vector<vector<int>> dp(n, vector<int>(2, 0));

        dp[0][1] = -prices[0];

        for(int i = 1; i < n; i++){

            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);

            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);

        }
        return dp[n - 1][0];
    }
};
```

## 子序列

[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // 经典DP解法，dp[i]是以nums[i]为最后一个元素子序列的长度
        int n = nums.size();
        vector<int> dp(n, 1);
        int max_length = 1;
        for(int i = 1; i < n; i++){
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            max_length = max(max_length, dp[i]);
        }
        return max_length;
    }
};
```

[674. 最长连续递增序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/)

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        int max_length = 1;
        for(int i = 1; i < n; i++){
            if(nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
            else dp[i] = 1;
            max_length = max(max_length, dp[i]);
        }
        return max_length;
    }
};
```

[718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/)

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        // 和递增子序列类似，这里的dp[n][m]是以n和m为结尾的重复字数组的长度
        int n = nums1.size(), m = nums2.size();
        vector<vector<int>>dp(n + 1, vector<int>(m + 1, 0));
        int max_length = 0;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = 0;
                max_length = max(max_length, dp[i][j]);
            }
        }
        return max_length;
    }
};
```

[1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/description/)

| **特性**          | **上一题 (最长公共子数组)**            | **这一题 (最长公共子序列)**            |
| ----------------- | -------------------------------------- | -------------------------------------- |
| **要求**          | 连续                                   | 不连续                                 |
| **DP定义**        | **必须以** `i-1`, `j-1` **结尾**的长度 | **截止到** `i-1`, `j-1` 的**最长**长度 |
| **`if (a == b)`** | `dp[i-1][j-1] + 1`                     | `dp[i-1][j-1] + 1`                     |
| **`if (a != b)`** | `0` (中断，归零)                       | `max(dp[i-1][j], dp[i][j-1])` (继承)   |
| **最终答案**      | `max(dp)` (整个表的最大值)             | `dp[m][n]` (右下角的最终值)            |

你问：为什么 `dp[i][j]` 不等于 `max(dp[i-1][j-1] + 1, dp[i-1][j], dp[i][j-1])`？

**答案：因为 `dp[i-1][j-1] + 1` 在数学上一定大于等于 `dp[i-1][j]` 和 `dp[i][j-1]`。**

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();
        // 这道题由于是公共子序列，所以dp[n][m]代表的是在n，m之前最长的公共子序列
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
        return dp[n][m];
    }
};
```

[392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/description/)

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int m = s.size();
        int n = t.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }

        return dp[m][n] == m;
    }
};
```

贪心算法，时间复杂度O(n)，空间复杂度O(1)

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int m = s.size();
        int n = t.size();
        int i = 0, j = 0;
        // 贪心算法
        while(i < m && j < n){
            if(s[i] == t[j]) i++;
            j++;
        }
        return i == m;
    }
};
```

[115. 不同的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/distinct-subsequences/description/)

| **类型**       | **常见/保证大小 (位)** | **范围 (近似)**              | **备注**                       |
| -------------- | ---------------------- | ---------------------------- | ------------------------------ |
| `int`          | 32位 (常见)            | -21亿 到 +21亿               | 默认使用，但可能溢出           |
| `unsigned int` | 32位 (常见)            | 0 到 +42亿                   | 用于非负数，正数范围翻倍       |
| `long`         | 32位 **或** 64位       | (不确定)                     | **不推荐使用**，大小因系统而异 |
| `long long`    | 64位 (保证至少)        | -9.2 x 10^18 到 +9.2 x 10^18 | 推荐的**带符号**64位整数       |
| `int64_t`      | 64位 (保证)            | -9.2 x 10^18 到 +9.2 x 10^18 | `long long` 的“明确”版本       |
| `uint64_t`     | 64位 (保证)            | 0 到 +1.8 x 10^19            | 推荐的**无符号**64位整数       |

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        // 动态规划，我们看的是在下标是i-1和j-1时，s和t这部分能不能匹配上
        int m = s.size();
        int n = t.size();
        vector<vector<uint64_t>>dp(m + 1, vector<uint64_t>(n + 1, 0));
        // 初始化
        for(int i = 0; i <= m; i++) dp[i][0] = 1;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                // 若匹配不上，则需要读取s的上一个部分和t的这一个部分的匹配数
                if(s[i - 1] != t[j - 1]) dp[i][j] = dp[i - 1][j];
                // 若匹配上了，有两种情况。第一种需要加上s和t的上一部分的匹配数，第二种是由于出现多种匹配的可能，需要加上s的上一个匹配数
                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
            }
        }
        return (int) dp[m][n];
    }
};
```

[583. 两个字符串的删除操作 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-operation-for-two-strings/)

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        // 子序列变种
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return m + n - 2 * dp[m][n];
    }
};
```

