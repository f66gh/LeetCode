#  10_动态规划

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

动规是由前一个状态推导出来的，而贪心是局部直接选最优的

**核心思想就是“用空间换时间”**，把计算过的结果存起来，避免重复计算。

## 基础题目

递归法：

```cpp
class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1 || n == 2) return 1;
        return fib(n - 1) + fib(n - 2);
    }
};
```

动态规划，自底向下

```cpp
class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;

        // 初始化一个数组，能存放下f(0)到f(n)的数
        vector<int> dp(n + 1);

        // 边界初始化
        dp[0] = 0;
        dp[1] = 1;

        // 递归式
        for(int i = 2; i < n + 1; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
};
```

记忆化搜索，自顶向下

```cpp
class Solution {
public:
    int fib(int n) {
         memo.assign(n + 1, -1);
         return dp(n);
    }
private:
    vector<int> memo;
    int dp(int n){
        if (n == 0) return 0;
        if (n == 1) return 1;

        // 检查备忘录
        if (memo[n] != -1) return memo[n]; 

        // 没看过
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
};
```

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)

暴力解法，超时

```cpp
class Solution {
public:
    int climbStairs(int n) {
        dp(n);
        return res;
    }
private:
    int res = 0;
    void dp(int n){
        if(n == 1){
            res++;
            return;
        }
        if(n == 2) res++;
        if(n <= 0) return;
        dp(n - 1);
        dp(n - 2);
        return;
    }
};
```

自底向上，表格法 (Tabulation)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        // dp是方法数
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2; //走到第二个台阶有两种方法
        // 对于台阶N，由于只能从n-1走1个阶或者从n-2走两个阶上来，故可列状态转移方程
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

自底向上的优化方法

在计算 `dp[i]` 时，你其实**只用到了 `dp[i-1]` 和 `dp[i-2]`**。你不需要存储整个数组。

我们可以只用两个变量来保存前两个状态，这叫做“滚动数组”思想，把空间复杂度从 $O(n)$ 降到了 $O(1)$。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        int prev_1 = 1;
        int prev_2 = 2; //走到第二个台阶有两种方法
        int cur = 0;
        // 对于台阶N，由于只能从n-1走1个阶或者从n-2走两个阶上来，故可列状态转移方程
        for(int i = 3; i <= n; i++){
            cur = prev_1 + prev_2;
            prev_1 = prev_2;
            prev_2 = cur;
        }
        return cur;
    }
};
```



自顶向下，备忘录法

```cpp
class Solution {
public:
    int climbStairs(int n) {
        memo.assign(n + 1, 0);
        return dp(n);
    }
private:
    vector<int> memo;

    int dp(int n){
        if(n <= 2) return n;
        if(memo[n] != 0) return memo[n];
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
};
```

[746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/submissions/675306280/)

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // 和爬楼梯类似，我们需要给每一个台阶都找一个最小爬上来的代价
        int n = cost.size();
        // 注意这里到达第零个台阶和第一个台阶的花费都是0
        int prev_1 = 0;
        int prev_2 = 0;
        int cur = 0;

        for(int i = 2; i <= n; i++){
            // 注意看好步数和从哪个台阶上的，prev_1表示到达上上的台阶的花费，Prev_2表示到达上个台阶的花费
            cur = min(prev_1 + cost[i - 2], prev_2 + cost[i - 1]);
            prev_1 = prev_2;
            prev_2 = cur;
        }

        return cur;
    }
};
```

[63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/description/)

我们要计算到达每个格子的**不同路径数量**。根据题意，要想到达 `(i, j)` 这个格子，机器人只能从它的**上方** `(i-1, j)` 或者**左方** `(i, j-1)` 过来。

因此，**“到达 `(i, j)` 的路径数”** 就等于 **“到达 `(i-1, j)` 的路径数”** 加上 **“到达 `(i, j-1)` 的路径数”**。

这就是动态规划的核心——把一个大问题（到达右下角）分解为一堆相关联的小问题（到达每一个中间格子）。



自底向上，时间复杂度是 $O(m \times n)$，空间复杂度是 $O(m \times n)$。

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        // 如果左上角没有障碍物再初始化
        if(obstacleGrid[0][0] != 1) dp[0][0] = 1;
        else return 0;

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i == 0 && j == 0) continue;
                // 遇到障碍物
                if(obstacleGrid[i][j] == 1) continue;
                if(i == 0) dp[i][j] = dp[i][j - 1];
                else if(j == 0) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
            }
        }

        return dp[m - 1][n - 1];
    }
};
```

滚动数组

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        // 压缩空间，用滚动数组法，设置上一行为记忆数组
        vector<int> dp(n, 0);
        // 如果左上角和右下角没有障碍物再初始化
        if(obstacleGrid[0][0] != 1) dp[0] = 1;
        else return 0;

        // 初始化第一行记忆数组
        for(int i = 1; i < n; i++){
            // 如果当前是障碍物则直接设为0
            if(obstacleGrid[0][i] != 1) dp[i] = dp[i - 1];
        }

        // 直接从第二行开始遍历
        for(int i = 1; i < m; i++){
            for(int j = 0; j < n; j++){
                // 遇到障碍物
                if(obstacleGrid[i][j] == 1) dp[j] = 0;
                else if(j == 0) ;
                else dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
```

[343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/description/)

- 时间复杂度：O(n^2)
- 空间复杂度：O(n)

```cpp
class Solution {
public:
    int integerBreak(int n) {
        // 核心思想：每个数切了一刀之后，可以拆分为两个数，这两个数要比较自己还是自己的最大乘积谁更大
        vector<int> dp(n + 1, 0);
        if(n == 2) return 1;
        if(n == 3) return 2;
        dp[2] = 1;
        for(int i = 3; i <= n; i++){
            for(int j = 1; j <= i / 2; j++){
                int k = i - j;
                int factor_1 = max(j, dp[j]);
                int factor_2 = max(k, dp[k]);
                dp[i] = max(dp[i], factor_1 * factor_2);
            }
        }
        return dp[n];
    }
};
```

[96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/description/)

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        // 这里的i是有多少个节点
        for(int i = 2; i <= n; i++){
            // 这里的j是以j为根节点
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

## 中等题

`dp` 数组的定义（里面存什么）完全取决于“问题要求什么”。

| **问题类型**             | **题目范例**                           | **问题“求什么”？**                                       | **dp[j] 的定义 (灵魂)**                                | **递推公式 (骨架)**                                          |
| ------------------------ | -------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 求最大价值**        | **416. 分割子集**   **1049. 石头重量** | "在容量 `j` 下，能装的**最大重量(价值)是多少**？"        | `dp[j]` = 容量为 `j` 时，能装的**最大重量**。          | `dp[j] = max(dp[j], dp[j-w] + v)`   (这里 `v` = `w`)         |
| **2. 求组合数**          | **494. 目标和**                        | "要装满容量 `j`，一共有**多少种方法**？"                 | `dp[j]` = 装满容量 `j` 的**方法总数**。                | `dp[j] = dp[j] + dp[j-w]`   (方法数 = 不放的方法 + 放的方法) |
| **3. 求最大价值 (变种)** | **474. 一和零 (本题)**                 | "在容量 `(j, k)` 下，能装的**最多物品数(长度)是多少**？" | `dp[j][k]` = 容量为 `j,k` 时，能装的**最大子集长度**。 | `dp[j][k] = max(dp[j][k], 1 + dp[j-z][k-o])`                 |

[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

0-1背包解法

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // 将问题转化为能否从Nums中调出nums/2的元素使得其和等于Nums的和
        int n = nums.size();
        int sum = 0;
        for(int i = 0; i < n; i++){
            sum += nums[i];
        }
        if(sum % 2 != 0) return false;
        int half = sum / 2;
        
        vector<vector<int>> dp(n, vector<int>(half + 1, 0));
        // 初始化第一行（物品0）
        for(int i = nums[0]; i <= half; i++){
            dp[0][i] = nums[0];
        }

        // 填充背包,从第二行开始填,i是物品
        for(int i = 1; i < n; i++){
            for(int j = 1; j <= half; j++){
                // 和上行一样
                if(nums[i] > j) dp[i][j] = dp[i - 1][j];
                // 判断谁更大
                else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);
            }
            // 判断当前物品行最后一格是否为half
            if(dp[i][half] == half) return true;
        }
        return false;
    }
};
```

滚动数组法

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // 将问题转化为能否从Nums中调出nums/2的元素使得其和等于Nums的和
        int n = nums.size();
        int sum = 0;
        for(int i = 0; i < n; i++){
            sum += nums[i];
        }
        if(sum % 2 != 0) return false;
        int half = sum / 2;
        
        // 滚动数组优化方法：由于第i行只需要第i-1行的数据
        vector<int> dp(half + 1);
        // 初始化第一行（物品0）
        for(int i = nums[0]; i <= half; i++){
            dp[i] = nums[0];
        }

        // 填充背包,从第二行开始填,i是物品
        for(int i = 1; i < n; i++){
            // 注意必须是倒序遍历容量
            for(int j = half; j >= 1; j--){
                // 和上行一样，不用动了
                if(nums[i] > j) ;
                // 判断谁更大
                else dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
            // 判断当前物品行最后一格是否为half
            if(dp[half] == half) return true;
        }
        return false;
    }
};
```

[1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/description/)

写法更优雅的滚动数组法

```cpp
class Solution {
public:
    // 核心思想：把石头分成重量最近的两堆
    // 从 stones 数组中挑选任意石头，在总重量不超过 sum / 2 的前提下，能达到的最大总重量是多少？
    int lastStoneWeightII(vector<int>& stones) {
        int n = stones.size();
        int sum = 0;
        for(int s : stones) sum += s;
        int half = sum / 2;
        vector<int> dp(half + 1, 0);
        // 不用初始化第一行了，在正常遍历中能够正确填充第一行
        for(int i = 0; i < n; i++){
            for(int j = half; j >= stones[i]; j--){
                dp[j] = max(dp[j], stones[i] + dp[j - stones[i]]);
            }
            // 不需要额外设置变量存储最大值，因为dp[half]已经经过Max筛选了
        }
        return sum - 2 * dp[half];
    }
};
```

[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/description/)

0-1背包组合问题写法

```cpp
class Solution {
public:
    // 转化为背包问题，找到sum + target / 2 的值就好
    int findTargetSumWays(vector<int>& nums, int target) {
        // 这道题和之前dp里边填重量不同，而是填装满这个背包的方法有多少种（组合问题）
        int sum = 0;
        int zeroNum = 0;
        for(int n : nums) {
            sum += n;
            // 需要用到0的个数
            if(n == 0) zeroNum++;
        }
        if(sum < abs(target)) return 0;
        if((sum + target) % 2 == 1) return 0;
        int half = (sum + target) / 2;
        int n = nums.size();
        // 滚动数组
        vector<int> dp(half + 1, 0);
        // 初始化第一行第一列，和正常的二维数组有区别
        dp[0] = 1;
        // 也不用初始化第一行
        // if(nums[0] != 0 && nums[0] <= half) dp[nums[0]] = 1;

        for(int i = 0; i < n; i++){
            for(int j = half; j >= nums[i]; j--){
                // 组合写法
                dp[j] = dp[j] + dp[j - nums[i]];
            }
        }
        return dp[half];
    }
};
```

[474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/description/)

这道题背的答案，太恶心了。

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(string s : strs){
            int zero = 0;
            int one = 0;
            for(char c : s){
                if(c == '0') zero++;
                else one++;
            }
            for(int i = m; i >= zero; i--){
                for(int j = n; j >= one; j--){
                    dp[i][j] = max(dp[i][j], 1 + dp[i - zero][j - one]);
                }
            }
        }
        return dp[m][n];
    }
};
```

