#  10_动态规划

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

动规是由前一个状态推导出来的，而贪心是局部直接选最优的

**核心思想就是“用空间换时间”**，把计算过的结果存起来，避免重复计算。

## 基础题目

递归法：

```cpp
class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1 || n == 2) return 1;
        return fib(n - 1) + fib(n - 2);
    }
};
```

动态规划，自底向下

```cpp
class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;

        // 初始化一个数组，能存放下f(0)到f(n)的数
        vector<int> dp(n + 1);

        // 边界初始化
        dp[0] = 0;
        dp[1] = 1;

        // 递归式
        for(int i = 2; i < n + 1; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
};
```

记忆化搜索，自顶向下

```cpp
class Solution {
public:
    int fib(int n) {
         memo.assign(n + 1, -1);
         return dp(n);
    }
private:
    vector<int> memo;
    int dp(int n){
        if (n == 0) return 0;
        if (n == 1) return 1;

        // 检查备忘录
        if (memo[n] != -1) return memo[n]; 

        // 没看过
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
};
```

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)

暴力解法，超时

```cpp
class Solution {
public:
    int climbStairs(int n) {
        dp(n);
        return res;
    }
private:
    int res = 0;
    void dp(int n){
        if(n == 1){
            res++;
            return;
        }
        if(n == 2) res++;
        if(n <= 0) return;
        dp(n - 1);
        dp(n - 2);
        return;
    }
};
```

自底向上，表格法 (Tabulation)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        // dp是方法数
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2; //走到第二个台阶有两种方法
        // 对于台阶N，由于只能从n-1走1个阶或者从n-2走两个阶上来，故可列状态转移方程
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

自底向上的优化方法

在计算 `dp[i]` 时，你其实**只用到了 `dp[i-1]` 和 `dp[i-2]`**。你不需要存储整个数组。

我们可以只用两个变量来保存前两个状态，这叫做“滚动数组”思想，把空间复杂度从 $O(n)$ 降到了 $O(1)$。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        int prev_1 = 1;
        int prev_2 = 2; //走到第二个台阶有两种方法
        int cur = 0;
        // 对于台阶N，由于只能从n-1走1个阶或者从n-2走两个阶上来，故可列状态转移方程
        for(int i = 3; i <= n; i++){
            cur = prev_1 + prev_2;
            prev_1 = prev_2;
            prev_2 = cur;
        }
        return cur;
    }
};
```



自顶向下，备忘录法

```cpp
class Solution {
public:
    int climbStairs(int n) {
        memo.assign(n + 1, 0);
        return dp(n);
    }
private:
    vector<int> memo;

    int dp(int n){
        if(n <= 2) return n;
        if(memo[n] != 0) return memo[n];
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
};
```

[746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/submissions/675306280/)

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // 和爬楼梯类似，我们需要给每一个台阶都找一个最小爬上来的代价
        int n = cost.size();
        // 注意这里到达第零个台阶和第一个台阶的花费都是0
        int prev_1 = 0;
        int prev_2 = 0;
        int cur = 0;

        for(int i = 2; i <= n; i++){
            // 注意看好步数和从哪个台阶上的，prev_1表示到达上上的台阶的花费，Prev_2表示到达上个台阶的花费
            cur = min(prev_1 + cost[i - 2], prev_2 + cost[i - 1]);
            prev_1 = prev_2;
            prev_2 = cur;
        }

        return cur;
    }
};
```

[63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/description/)

我们要计算到达每个格子的**不同路径数量**。根据题意，要想到达 `(i, j)` 这个格子，机器人只能从它的**上方** `(i-1, j)` 或者**左方** `(i, j-1)` 过来。

因此，**“到达 `(i, j)` 的路径数”** 就等于 **“到达 `(i-1, j)` 的路径数”** 加上 **“到达 `(i, j-1)` 的路径数”**。

这就是动态规划的核心——把一个大问题（到达右下角）分解为一堆相关联的小问题（到达每一个中间格子）。



自底向上，时间复杂度是 $O(m \times n)$，空间复杂度是 $O(m \times n)$。

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        // 如果左上角没有障碍物再初始化
        if(obstacleGrid[0][0] != 1) dp[0][0] = 1;
        else return 0;

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i == 0 && j == 0) continue;
                // 遇到障碍物
                if(obstacleGrid[i][j] == 1) continue;
                if(i == 0) dp[i][j] = dp[i][j - 1];
                else if(j == 0) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
            }
        }

        return dp[m - 1][n - 1];
    }
};
```

滚动数组

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        // 压缩空间，用滚动数组法，设置上一行为记忆数组
        vector<int> dp(n, 0);
        // 如果左上角和右下角没有障碍物再初始化
        if(obstacleGrid[0][0] != 1) dp[0] = 1;
        else return 0;

        // 初始化第一行记忆数组
        for(int i = 1; i < n; i++){
            // 如果当前是障碍物则直接设为0
            if(obstacleGrid[0][i] != 1) dp[i] = dp[i - 1];
        }

        // 直接从第二行开始遍历
        for(int i = 1; i < m; i++){
            for(int j = 0; j < n; j++){
                // 遇到障碍物
                if(obstacleGrid[i][j] == 1) dp[j] = 0;
                else if(j == 0) ;
                else dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
```

[343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/description/)

- 时间复杂度：O(n^2)
- 空间复杂度：O(n)

```cpp
class Solution {
public:
    int integerBreak(int n) {
        // 核心思想：每个数切了一刀之后，可以拆分为两个数，这两个数要比较自己还是自己的最大乘积谁更大
        vector<int> dp(n + 1, 0);
        if(n == 2) return 1;
        if(n == 3) return 2;
        dp[2] = 1;
        for(int i = 3; i <= n; i++){
            for(int j = 1; j <= i / 2; j++){
                int k = i - j;
                int factor_1 = max(j, dp[j]);
                int factor_2 = max(k, dp[k]);
                dp[i] = max(dp[i], factor_1 * factor_2);
            }
        }
        return dp[n];
    }
};
```

[96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/description/)

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        // 这里的i是有多少个节点
        for(int i = 2; i <= n; i++){
            // 这里的j是以j为根节点
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

