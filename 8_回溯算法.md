# 8_回溯算法

## 通用模板

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 组合问题

[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        size = k;
        max = n;
        vector<int> vec;
        backtracking(1, vec);
        return res;
    }
private:
    vector<vector<int>> res;
    int size = 0;
    int max = 0;
    // 我们是反复用vec作为path，故传引用最好。
    void backtracking(int s, vector<int> &vec){
        if(vec.size() == size) {
            res.push_back(vec);
            return;
        }
        // 剪枝操作
        // 还需要 (size - vec.size()) 个数
        // 区间 [i, max] 中至少要有 (size - vec.size()) 个数
        // max - i + 1 >= size - vec.size()
        // i <= max - (size - vec.size()) + 1
        for(int i = s; i <= max - (size - vec.size()) + 1; i++){
            vec.push_back(i);
            backtracking(i + 1, vec);
            vec.pop_back();
        }
    }
};
```

[216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/description/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        size = k;
        sum = n;
        vector<int> path;
        backtracking(path, 1);
        return res;
    }
private:
    int size = 0;
    int sum = 0;
    vector<vector<int>> res;
    void backtracking(vector<int>& path, int s){
        if(path.size() == size) {
            int temp = 0;
            for(int j : path) temp += j;
            if(sum == temp) res.push_back(path);
            return;
        }
        for(int i = s; i <= 10 + path.size() - size; i++){
            path.push_back(i);
            backtracking(path, i + 1);
            path.pop_back();
        }
    }
};
```

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

```cpp
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        dig = digits;
        size = digits.size();
        string path;
        backtracking(0, path);
        return res;
    }
private:
    string dig;
    int size;
    vector<string> res;
    vector<string> words = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    void backtracking(int n, string& path){
        if(n == size){
            res.push_back(path);
            return;
        }
        for(char c : words[dig[n] - '0' - 2]){
            path.push_back(c);
            backtracking(n + 1, path);
            path.pop_back();
        }
    }
};
```

[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sum = target;
        size = candidates.size();
        cand = candidates;
        vector<int> path;
        backtracking(path, 0);
        return res;
    }

private: 
    int sum = 0;
    int temp = 0;
    int size = 0;
    vector<vector<int>> res;
    vector<int> cand;
    void backtracking(vector<int>& path, int s){
        if(temp >= sum){
            if(temp == sum) res.push_back(path);
            return;
        }
        for(int i = s; i < size; i++){
            temp += cand[i];
            path.push_back(cand[i]);
            backtracking(path, i);
            path.pop_back();
            temp -= cand[i];
        }
    }
};
```

[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int> path;
        vector<vector<int>> res;
        // 先排序，为剪枝做准备
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, path, res);
        return res;
    }
private:
    void backtracking(const vector<int>& candidates, int target, int currentSum, 
        int startIndex, vector<int>& path, vector<vector<int>>& res){
        if(currentSum == target){
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i < candidates.size(); i++){
            if(currentSum + candidates[i] > target) break;
            // 在这里去重
            if(i > startIndex && candidates[i] == candidates[i - 1]) continue;
            path.push_back(candidates[i]);
            currentSum += candidates[i];
            backtracking(candidates, target, currentSum, i + 1, path, res);
            path.pop_back();
            currentSum -= candidates[i];
        }
    }
};
```

## 分割问题

[131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/)

```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<string> path;
        backtracking(0, s, path);
        return res;
    }
private:
    vector<vector<string>> res;
    // 这里把子串结束位置定为索引
    void backtracking(int start, string s, vector<string> &path){
        if(s.size() == start) {
            res.push_back(path);
            return;
        }
        for(int end = start; end < s.size(); end++){
            string p = s.substr(start, end - start + 1);
            if(check(p)) {
                path.push_back(p);
                backtracking(end + 1, s, path);
                path.pop_back();
            }
            // 当不是回文串时，自然会让子串变长
        }
    }
    bool check(string p){
        for(int i = 0; i < p.size() / 2; i++){
            if(p[i] != p[p.size() - 1 - i]) return false;
        }
        return true;
    }
};
```

[93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/description/)

自己写的shit

```cpp
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        vector<string> res;
        if(s.size() < 4 || s.size() > 12) return res;
        string path;
        backtracking(res, path, s, 0, 0);
        return res;
    }
private:
    void backtracking(vector<string> &res, string &path, string& s, int start, int deep){
        if(start == s.size()){
            res.push_back(path);
            return;
        }
        // 
        for(int end = start; end < s.size(); end++){
            if(end - start > 2) break;
            string p = s.substr(start, end - start + 1);
            if(check(p) && deep < 4 && s.size() + 3 * deep - end < 11 && s.size() - end + deep >= 4 ){
                int size = path.size();
                path += p;
                if(deep != 3) path += '.';
                backtracking(res, path, s, end + 1, deep + 1);
                path.erase(size, end - start + 2);
            }
        }
    }
    bool check(string p){
        if(p[0] == '0' && p.size() != 1) return false;
        if(stoi(p) >= 0 && stoi(p) <= 255) return true;
        return false;
    }
};

```

优化点：

* vector的增加和删除比字符串的拼接删改效率高
* 可读性太差

| **特性**            | **vector::push_back / pop_back**           | **string::append / erase**                   |
| ------------------- | ------------------------------------------ | -------------------------------------------- |
| **API设计**         | 专为在末尾增删单个元素设计，**简单、安全** | 通用文本处理，`erase` 功能强大但**使用复杂** |
| **回溯场景**        | **完美契合**，`pop_back` 语义清晰          | 需要用 `erase` **手动模拟**回溯，易错        |
| **`pop_back` 性能** | **O(1)**，只需修改大小，不移动数据         | `string` 也有 `pop_back`，同样 O(1)          |
| **`erase` 性能**    | 从中间删除是 **O(N)**，因为需要移动数据    | 从中间删除是 **O(N)**，因为需要移动数据      |
| **内存模型**        | 总是使用堆内存                             | 短字符串使用 SSO (栈)，长字符串使用堆        |

## 子集问题

[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/description/)

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        backtracking(nums, res, path, 0);
        return res;
    }
private:
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& path, int start){
        res.push_back(path);
        for(int i = start; i < nums.size(); i++){
            path.push_back(nums[i]);
            backtracking(nums, res, path, i + 1);
            path.pop_back();
        }
    }
};
```

[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/description/)

```cpp
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        sort(nums.begin(), nums.end());
        backtracking(nums, res, path, 0);
        return res;
    }
private:
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& path, int start){
        res.push_back(path);
        for(int i = start; i < nums.size(); i++){
            if(i > start && nums[i] == nums[i - 1]) continue;
            path.push_back(nums[i]);
            backtracking(nums, res, path, i + 1);
            path.pop_back();
        }
    }
};
```

[491. 非递减子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

```cpp
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        backtracking(nums, res, path, 0);
        return res;
    }
private:
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& path, int start){
        if(path.size() > 1) res.push_back(path);
        for(int i = start; i < nums.size(); i++){
            if(start > 0 && nums[i] < nums[start - 1]) continue;
            if(i > start && check(nums, start, i)) continue;
            path.push_back(nums[i]);
            backtracking(nums, res, path, i + 1);
            path.pop_back();
        }
    }
    bool check(vector<int>& nums, int start, int end){
        for(int i = start; i < end; i++) {
            if(nums[i] == nums[end]) return true;
        }
        return false;
    }
};
```

优化点：

* 用哈希代替for循环找到数字是否已经在本轮循环中出现
* vector的back可以返回最后一个元素

```cpp
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        backtracking(nums, res, path, 0);
        return res;
    }
private:
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& path, int start){
        if(path.size() > 1) res.push_back(path);
        unordered_set<int> uset; // 使用set对本层元素进行去重
        for(int i = start; i < nums.size(); i++){
            if(start > 0 && nums[i] < path.back()) continue;
            if(uset.find(nums[i]) != uset.end()) continue;
            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, res, path, i + 1);
            path.pop_back();
        }
    }
};
```

