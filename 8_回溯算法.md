# 8_回溯算法

## 通用模板

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 组合问题

[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        size = k;
        max = n;
        vector<int> vec;
        backtracking(1, vec);
        return res;
    }
private:
    vector<vector<int>> res;
    int size = 0;
    int max = 0;
    // 我们是反复用vec作为path，故传引用最好。
    void backtracking(int s, vector<int> &vec){
        if(vec.size() == size) {
            res.push_back(vec);
            return;
        }
        // 剪枝操作
        // 还需要 (size - vec.size()) 个数
        // 区间 [i, max] 中至少要有 (size - vec.size()) 个数
        // max - i + 1 >= size - vec.size()
        // i <= max - (size - vec.size()) + 1
        for(int i = s; i <= max - (size - vec.size()) + 1; i++){
            vec.push_back(i);
            backtracking(i + 1, vec);
            vec.pop_back();
        }
    }
};
```

[216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/description/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        size = k;
        sum = n;
        vector<int> path;
        backtracking(path, 1);
        return res;
    }
private:
    int size = 0;
    int sum = 0;
    vector<vector<int>> res;
    void backtracking(vector<int>& path, int s){
        if(path.size() == size) {
            int temp = 0;
            for(int j : path) temp += j;
            if(sum == temp) res.push_back(path);
            return;
        }
        for(int i = s; i <= 10 + path.size() - size; i++){
            path.push_back(i);
            backtracking(path, i + 1);
            path.pop_back();
        }
    }
};
```

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

```cpp
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        dig = digits;
        size = digits.size();
        string path;
        backtracking(0, path);
        return res;
    }
private:
    string dig;
    int size;
    vector<string> res;
    vector<string> words = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    void backtracking(int n, string& path){
        if(n == size){
            res.push_back(path);
            return;
        }
        for(char c : words[dig[n] - '0' - 2]){
            path.push_back(c);
            backtracking(n + 1, path);
            path.pop_back();
        }
    }
};
```

[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sum = target;
        size = candidates.size();
        cand = candidates;
        vector<int> path;
        backtracking(path, 0);
        return res;
    }

private: 
    int sum = 0;
    int temp = 0;
    int size = 0;
    vector<vector<int>> res;
    vector<int> cand;
    void backtracking(vector<int>& path, int s){
        if(temp >= sum){
            if(temp == sum) res.push_back(path);
            return;
        }
        for(int i = s; i < size; i++){
            temp += cand[i];
            path.push_back(cand[i]);
            backtracking(path, i);
            path.pop_back();
            temp -= cand[i];
        }
    }
};
```

[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int> path;
        vector<vector<int>> res;
        // 先排序，为剪枝做准备
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, path, res);
        return res;
    }
private:
    void backtracking(const vector<int>& candidates, int target, int currentSum, 
        int startIndex, vector<int>& path, vector<vector<int>>& res){
        if(currentSum == target){
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i < candidates.size(); i++){
            if(currentSum + candidates[i] > target) break;
            // 在这里去重
            if(i > startIndex && candidates[i] == candidates[i - 1]) continue;
            path.push_back(candidates[i]);
            currentSum += candidates[i];
            backtracking(candidates, target, currentSum, i + 1, path, res);
            path.pop_back();
            currentSum -= candidates[i];
        }
    }
};
```

## 分割问题

[131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/)

```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<string> path;
        backtracking(0, s, path);
        return res;
    }
private:
    vector<vector<string>> res;
    // 这里把子串结束位置定为索引
    void backtracking(int start, string s, vector<string> &path){
        if(s.size() == start) {
            res.push_back(path);
            return;
        }
        for(int end = start; end < s.size(); end++){
            string p = s.substr(start, end - start + 1);
            if(check(p)) {
                path.push_back(p);
                backtracking(end + 1, s, path);
                path.pop_back();
            }
            // 当不是回文串时，自然会让子串变长
        }
    }
    bool check(string p){
        for(int i = 0; i < p.size() / 2; i++){
            if(p[i] != p[p.size() - 1 - i]) return false;
        }
        return true;
    }
};
```

[93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/description/)

自己写的shit

```cpp
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        vector<string> res;
        if(s.size() < 4 || s.size() > 12) return res;
        string path;
        backtracking(res, path, s, 0, 0);
        return res;
    }
private:
    void backtracking(vector<string> &res, string &path, string& s, int start, int deep){
        if(start == s.size()){
            res.push_back(path);
            return;
        }
        // 
        for(int end = start; end < s.size(); end++){
            if(end - start > 2) break;
            string p = s.substr(start, end - start + 1);
            if(check(p) && deep < 4 && s.size() + 3 * deep - end < 11 && s.size() - end + deep >= 4 ){
                int size = path.size();
                path += p;
                if(deep != 3) path += '.';
                backtracking(res, path, s, end + 1, deep + 1);
                path.erase(size, end - start + 2);
            }
        }
    }
    bool check(string p){
        if(p[0] == '0' && p.size() != 1) return false;
        if(stoi(p) >= 0 && stoi(p) <= 255) return true;
        return false;
    }
};

```

优化点：

* vector的增加和删除比字符串的拼接删改效率高
* 可读性太差

| **特性**            | **vector::push_back / pop_back**           | **string::append / erase**                   |
| ------------------- | ------------------------------------------ | -------------------------------------------- |
| **API设计**         | 专为在末尾增删单个元素设计，**简单、安全** | 通用文本处理，`erase` 功能强大但**使用复杂** |
| **回溯场景**        | **完美契合**，`pop_back` 语义清晰          | 需要用 `erase` **手动模拟**回溯，易错        |
| **`pop_back` 性能** | **O(1)**，只需修改大小，不移动数据         | `string` 也有 `pop_back`，同样 O(1)          |
| **`erase` 性能**    | 从中间删除是 **O(N)**，因为需要移动数据    | 从中间删除是 **O(N)**，因为需要移动数据      |
| **内存模型**        | 总是使用堆内存                             | 短字符串使用 SSO (栈)，长字符串使用堆        |

## 子集问题

[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/description/)

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        backtracking(nums, res, path, 0);
        return res;
    }
private:
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& path, int start){
        res.push_back(path);
        for(int i = start; i < nums.size(); i++){
            path.push_back(nums[i]);
            backtracking(nums, res, path, i + 1);
            path.pop_back();
        }
    }
};
```

[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/description/)

```cpp
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        sort(nums.begin(), nums.end());
        backtracking(nums, res, path, 0);
        return res;
    }
private:
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& path, int start){
        res.push_back(path);
        for(int i = start; i < nums.size(); i++){
            if(i > start && nums[i] == nums[i - 1]) continue;
            path.push_back(nums[i]);
            backtracking(nums, res, path, i + 1);
            path.pop_back();
        }
    }
};
```

[491. 非递减子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

```cpp
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        backtracking(nums, res, path, 0);
        return res;
    }
private:
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& path, int start){
        if(path.size() > 1) res.push_back(path);
        for(int i = start; i < nums.size(); i++){
            if(start > 0 && nums[i] < nums[start - 1]) continue;
            if(i > start && check(nums, start, i)) continue;
            path.push_back(nums[i]);
            backtracking(nums, res, path, i + 1);
            path.pop_back();
        }
    }
    bool check(vector<int>& nums, int start, int end){
        for(int i = start; i < end; i++) {
            if(nums[i] == nums[end]) return true;
        }
        return false;
    }
};
```

优化点：

* 用哈希代替for循环找到数字是否已经在本轮循环中出现
* vector的back可以返回最后一个元素

```cpp
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        backtracking(nums, res, path, 0);
        return res;
    }
private:
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& path, int start){
        if(path.size() > 1) res.push_back(path);
        unordered_set<int> uset; // 使用set对本层元素进行去重
        for(int i = start; i < nums.size(); i++){
            if(start > 0 && nums[i] < path.back()) continue;
            if(uset.find(nums[i]) != uset.end()) continue;
            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, res, path, i + 1);
            path.pop_back();
        }
    }
};
```

## 排列问题

[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/)

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        // unordered_set<int> uset;
        // 由于题干中明确指出没有重复的数字，节省因为hash冲突导致的时间问题
        vector<bool> used(nums.size(), false);
        backtracking(nums, path, res, used);
        return res;
    }
private:
    void backtracking(vector<int>& nums, vector<int>& path, vector<vector<int>>& res, vector<bool>& used){
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            if(used[i]) continue;
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, path, res, used);
            path.pop_back();
            used[i] = false;
        }
    }
};
```

[47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/)

```
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtracking(nums, path, res, used);
        return res;
    }

private:
    void backtracking(vector<int>& nums, vector<int>& path,
        vector<vector<int>>& res, vector<bool>& used) {
        if (path.size() == nums.size()) {
            res.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if(used[i]) continue;
            // 关键剪枝逻辑：
            // 1. i > 0 保证了 nums[i-1] 是有效的
            // 2. nums[i] == nums[i-1] 说明遇到了重复元素
            // 3. !used[i-1] 说明前一个相同的元素在“本层”递归中未被使用
            // 如果前一个相同的元素未被使用，那么当前这个元素我们也不使用，以避免重复
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, path, res, used);
            path.pop_back();
            used[i] = false;
        }
    }
};
```

## 棋盘问题

[51. N 皇后 - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens/description/)

```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> res;
        // 二叉树的每一叉表示一种可能的棋盘排列
        // path保证一行中只有一个皇后
        vector<int> path;
        // used保证一列中只有一个皇后
        vector<bool> used(n, false);
        for(int i = 0; i < n; i++) init += ".";
        backtracking(res, path, used, n);
        return res;
    }
private:
    string init;
    void backtracking(vector<vector<string>>& res, vector<int>& path, vector<bool> &used, int n){
        if(path.size() == n){
            res.push_back(trans(path));
            return;
        }
        // i表示的是列号，path.size是有多少行
        for(int i = 0; i < n; i++){
            if(used[i]) continue;
            // if判断斜对角是否只有一个皇后
            if(check(path, i, n)) continue;
            used[i] = true;
            path.push_back(i);
            backtracking(res, path, used, n);
            path.pop_back();
            used[i] = false;
        }
    }
    bool check(vector<int>& path, int i, int n){
        // 在path.size - j行中，i - j和i + j列位置处不能有皇后
        for(int j = 1; j <= path.size(); j++){
            if(j <= i && path[path.size() - j] == i - j) return true;
            if(i + j < n && path[path.size() - j] == i + j) return true;
        }
        return false;
    }
    vector<string> trans(vector<int>& path){
        vector<string> str(path.size(), init);
        for(int i = 0; i < path.size(); i++) str[i][path[i]] = 'Q';
        return str;
    }
};
```

优化版本：

```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> res;
        // 二叉树的每一叉表示一种可能的棋盘排列
        // path保证一行中只有一个皇后
        vector<int> path;
        // used保证一列中只有一个皇后
        vector<bool> used(n, false);
        for(int i = 0; i < n; i++) init += ".";
        vector<bool> diag1(2*n-1, false);
        vector<bool> diag2(2*n-1, false);
        backtracking(res, path, used, n, diag1, diag2);
        return res;
    }
private:
    string init;
    void backtracking(vector<vector<string>>& res, vector<int>& path, vector<bool> &used, int n, vector<bool>& diag1, vector<bool>& diag2){
        if(path.size() == n){
            res.push_back(trans(path));
            return;
        }
        // i表示的是列号，path.size是有多少行
        for(int i = 0; i < n; i++){
            if(used[i]) continue;
            // if判断斜对角是否只有一个皇后，用同一个主(副)对角线行号和列号减（加）起来是一样的性质优化时间
            int diag1_index = i - path.size() + n - 1;
            int diag2_index = i + path.size();
            if(diag1[diag1_index] || diag2[diag2_index]) continue;
            diag1[diag1_index] = true;
            diag2[diag2_index] = true;
            used[i] = true;
            path.push_back(i);
            backtracking(res, path, used, n, diag1, diag2);
            path.pop_back();
            used[i] = false;
            diag1[diag1_index] = false;
            diag2[diag2_index] = false;
        }
    }
    vector<string> trans(vector<int>& path){
        vector<string> str(path.size(), init);
        for(int i = 0; i < path.size(); i++) str[i][path[i]] = 'Q';
        return str;
    }
};
```

[37. 解数独 - 力扣（LeetCode）](https://leetcode.cn/problems/sudoku-solver/description/)
（自己没做出来）

```cpp
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        vector<vector<bool>> cols(9, vector<bool>(9, false));
        vector<vector<bool>> rows(9, vector<bool>(9, false));
        vector<vector<bool>> nets(9, vector<bool>(9, false));
        getUsed(board, cols, rows, nets);
        // 注意这里必须要传solved这个引用而不能直接传false
        bool solved = false;
        backtracking(board, cols, rows, nets, 0, 0, solved);
        return;
    }
private:

    // 应该把整个棋盘看成一个一位数组，而不是二维的，这样就好分析多了。solved用于找到解后快速回溯（因为题目保证只有一个解）
    void backtracking(vector<vector<char>>& board, vector<vector<bool>>& cols, vector<vector<bool>>& rows, vector<vector<bool>>& nets, int row, int col, bool& solved){
        if(solved) return;
        // 这一行搜索完毕，找到下一行
        if(col == 9){
            col = 0;
            row++;
        }
        // 所有9行都处理完毕，说明找到了一个解
        if (row == 9) {
            solved = true;
            return;
        }
        // 处理当前格子
        // 如果已经有数字，则跳过，直接处理下一个格子
        if (board[row][col] != '.') {
            backtracking(board, cols, rows, nets, row, col + 1, solved);
            return; // 保证在 solved 为 true 时能正确退出
        }
        // 如果是空格
        for(char num='1'; num <= '9'; num++){
            int k = num - '1'; // 转为0-8索引
            if(rows[row][k] || cols[col][k] || nets[getNet(row, col)][k]) continue; // 若当前数字在行、列、宫存在则找下一个数字
            updateUsed(cols, rows, nets, row, col, k, true);
            board[row][col] = num;
            backtracking(board, cols, rows, nets, row, col + 1, solved);
            if(!solved){ // 只有还没找到解时才会正常回溯
                board[row][col] = '.';
                updateUsed(cols, rows, nets, row, col, k, false);
            }
            else return;
        }
    }
    void getUsed(vector<vector<char>>& board, vector<vector<bool>>& cols, vector<vector<bool>>& rows, vector<vector<bool>>& nets){
        for(int i = 0; i < 9; i++){
            for(int j = 0; j < 9; j++){
                int k = board[i][j] - '1';
                if(k >= 0 && k <= 8) {
                    // 第i行和第j列中的k出现过了
                    cols[j][k] = true;
                    rows[i][k] = true;
                    nets[getNet(i, j)][k] = true;
                }
            }
        }
    }
    void updateUsed(vector<vector<bool>>& cols, vector<vector<bool>>& rows, vector<vector<bool>>& nets, int row, int col, int k, bool isAdd){
            rows[row][k] = isAdd;
            cols[col][k] = isAdd;
            nets[getNet(row, col)][k] = isAdd;
    }
    int getNet(int row, int col){
        return (row / 3) * 3 + (col / 3);
    }
};
```

