# 8_回溯算法

## 通用模板

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 组合问题

[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        size = k;
        max = n;
        vector<int> vec;
        backtracking(1, vec);
        return res;
    }
private:
    vector<vector<int>> res;
    int size = 0;
    int max = 0;
    // 我们是反复用vec作为path，故传引用最好。
    void backtracking(int s, vector<int> &vec){
        if(vec.size() == size) {
            res.push_back(vec);
            return;
        }
        // 剪枝操作
        // 还需要 (size - vec.size()) 个数
        // 区间 [i, max] 中至少要有 (size - vec.size()) 个数
        // max - i + 1 >= size - vec.size()
        // i <= max - (size - vec.size()) + 1
        for(int i = s; i <= max - (size - vec.size()) + 1; i++){
            vec.push_back(i);
            backtracking(i + 1, vec);
            vec.pop_back();
        }
    }
};
```

[216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/description/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        size = k;
        sum = n;
        vector<int> path;
        backtracking(path, 1);
        return res;
    }
private:
    int size = 0;
    int sum = 0;
    vector<vector<int>> res;
    void backtracking(vector<int>& path, int s){
        if(path.size() == size) {
            int temp = 0;
            for(int j : path) temp += j;
            if(sum == temp) res.push_back(path);
            return;
        }
        for(int i = s; i <= 10 + path.size() - size; i++){
            path.push_back(i);
            backtracking(path, i + 1);
            path.pop_back();
        }
    }
};
```

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

```cpp
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        dig = digits;
        size = digits.size();
        string path;
        backtracking(0, path);
        return res;
    }
private:
    string dig;
    int size;
    vector<string> res;
    vector<string> words = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    void backtracking(int n, string& path){
        if(n == size){
            res.push_back(path);
            return;
        }
        for(char c : words[dig[n] - '0' - 2]){
            path.push_back(c);
            backtracking(n + 1, path);
            path.pop_back();
        }
    }
};
```

[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sum = target;
        size = candidates.size();
        cand = candidates;
        vector<int> path;
        backtracking(path, 0);
        return res;
    }

private: 
    int sum = 0;
    int temp = 0;
    int size = 0;
    vector<vector<int>> res;
    vector<int> cand;
    void backtracking(vector<int>& path, int s){
        if(temp >= sum){
            if(temp == sum) res.push_back(path);
            return;
        }
        for(int i = s; i < size; i++){
            temp += cand[i];
            path.push_back(cand[i]);
            backtracking(path, i);
            path.pop_back();
            temp -= cand[i];
        }
    }
};
```

[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int> path;
        vector<vector<int>> res;
        // 先排序，为剪枝做准备
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, path, res);
        return res;
    }
private:
    void backtracking(const vector<int>& candidates, int target, int currentSum, 
        int startIndex, vector<int>& path, vector<vector<int>>& res){
        if(currentSum == target){
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i < candidates.size(); i++){
            if(currentSum + candidates[i] > target) break;
            // 在这里去重
            if(i > startIndex && candidates[i] == candidates[i - 1]) continue;
            path.push_back(candidates[i]);
            currentSum += candidates[i];
            backtracking(candidates, target, currentSum, i + 1, path, res);
            path.pop_back();
            currentSum -= candidates[i];
        }
    }
};
```

## 分割问题

[131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/)

```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<string> path;
        backtracking(0, s, path);
        return res;
    }
private:
    vector<vector<string>> res;
    // 这里把子串结束位置定为索引
    void backtracking(int start, string s, vector<string> path){
        if(s.size() == start) {
            res.push_back(path);
            return;
        }
        for(int end = start; end < s.size(); end++){
            string p = s.substr(start, end - start + 1);
            if(check(p)) {
                path.push_back(p);
                backtracking(end + 1, s, path);
                path.pop_back();
            }
            // 当不是回文串时，自然会让子串变长
        }
    }
    bool check(string p){
        for(int i = 0; i < p.size() / 2; i++){
            if(p[i] != p[p.size() - 1 - i]) return false;
        }
        return true;
    }
};
```

