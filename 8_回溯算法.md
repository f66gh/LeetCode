# 8_回溯算法

## 通用模板

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 组合问题

[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        size = k;
        max = n;
        vector<int> vec;
        backtracking(1, vec);
        return res;
    }
private:
    vector<vector<int>> res;
    int size = 0;
    int max = 0;
    // 我们是反复用vec作为path，故传引用最好。
    void backtracking(int s, vector<int> &vec){
        if(vec.size() == size) {
            res.push_back(vec);
            return;
        }
        // 剪枝操作
        // 还需要 (size - vec.size()) 个数
        // 区间 [i, max] 中至少要有 (size - vec.size()) 个数
        // max - i + 1 >= size - vec.size()
        // i <= max - (size - vec.size()) + 1
        for(int i = s; i <= max - (size - vec.size()) + 1; i++){
            vec.push_back(i);
            backtracking(i + 1, vec);
            vec.pop_back();
        }
    }
};
```

[216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/description/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        size = k;
        sum = n;
        vector<int> path;
        backtracking(path, 1);
        return res;
    }
private:
    int size = 0;
    int sum = 0;
    vector<vector<int>> res;
    void backtracking(vector<int>& path, int s){
        if(path.size() == size) {
            int temp = 0;
            for(int j : path) temp += j;
            if(sum == temp) res.push_back(path);
            return;
        }
        for(int i = s; i <= 10 + path.size() - size; i++){
            path.push_back(i);
            backtracking(path, i + 1);
            path.pop_back();
        }
    }
};
```

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

```cpp
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        dig = digits;
        size = digits.size();
        string path;
        backtracking(0, path);
        return res;
    }
private:
    string dig;
    int size;
    vector<string> res;
    vector<string> words = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    void backtracking(int n, string& path){
        if(n == size){
            res.push_back(path);
            return;
        }
        for(char c : words[dig[n] - '0' - 2]){
            path.push_back(c);
            backtracking(n + 1, path);
            path.pop_back();
        }
    }
};
```

