# 12_图论

[997. 找到小镇的法官 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-town-judge/description/)

看成有向图，就是找出度为 0 且入度为 *n*−1 的那个人

```cpp
class Solution {
public:
    int findJudge(int n, vector<vector<int>>& trust) {
        int m = trust.size();
        int in_degree[1000];
        int out_degree[1000];
        for(int i = 0; i < 1000; i++) {
            in_degree[i] = 0;
            out_degree[i] = 0;
        }
        for(int i = 0; i < m; i++){
            in_degree[trust[i][0] - 1]++;
            out_degree[trust[i][1] - 1]++;
        }
        for(int i = 0; i < 1000; i++){
            if(in_degree[i] == n - 1 && out_degree[i] == 0) return i + 1;
        }
        return -1;
    }
};
```

[733. 图像渲染 - 力扣（LeetCode）](https://leetcode.cn/problems/flood-fill/)

```cpp
class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int old_color = image[sr][sc];
        // 【关键补丁】如果新颜色和旧颜色一样，直接不处理，防止死循环
        if (old_color == color) return image;
        DFS(image, sr, sc, color, old_color);
        return image;
    }

private:
    void DFS(vector<vector<int>>& image, int sr, int sc, int color, int old_color){
        int m = image.size();
        int n = image[0].size();
        if(sr < 0 || sc < 0 || sr >= m || sc >= n) return ;
        // 注意别Stack Overflow
        if(image[sr][sc] != old_color) return;
        // 自己
        image[sr][sc] = color;
        // 上下左右
        DFS(image, sr - 1, sc, color, old_color);
        DFS(image, sr + 1, sc, color, old_color);
        DFS(image, sr, sc - 1, color, old_color);
        DFS(image, sr, sc + 1, color, old_color);
    }
};
```

[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/description/)

DFS版本

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        // 深度遍历思想，沉岛法
        int count = 0;
        int m = grid.size(), n = grid[0].size();
        // 遍历整个grid
        for(int i = 0; i < m ; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == '1') {
                    count++;
                    DFS(grid, i, j);
                }
            }
        }
        return count;
    }
private:
    void DFS(vector<vector<char>>& grid, int r, int c){
        int m = grid.size(), n = grid[0].size();
        if(r < 0 || c < 0 || r >= m || c >= n) return;
        if(grid[r][c] == '0') return;
        grid[r][c] = '0';
        DFS(grid, r + 1, c);
        DFS(grid, r - 1, c);
        DFS(grid, r, c + 1);
        DFS(grid, r, c - 1);
    }
};
```

