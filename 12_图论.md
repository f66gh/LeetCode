# 12_图论

[997. 找到小镇的法官 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-town-judge/description/)

看成有向图，就是找出度为 0 且入度为 *n*−1 的那个人

```cpp
class Solution {
public:
    int findJudge(int n, vector<vector<int>>& trust) {
        int m = trust.size();
        int in_degree[1000];
        int out_degree[1000];
        for(int i = 0; i < 1000; i++) {
            in_degree[i] = 0;
            out_degree[i] = 0;
        }
        for(int i = 0; i < m; i++){
            in_degree[trust[i][0] - 1]++;
            out_degree[trust[i][1] - 1]++;
        }
        for(int i = 0; i < 1000; i++){
            if(in_degree[i] == n - 1 && out_degree[i] == 0) return i + 1;
        }
        return -1;
    }
};
```

[733. 图像渲染 - 力扣（LeetCode）](https://leetcode.cn/problems/flood-fill/)

```cpp
class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int old_color = image[sr][sc];
        // 【关键补丁】如果新颜色和旧颜色一样，直接不处理，防止死循环
        if (old_color == color) return image;
        DFS(image, sr, sc, color, old_color);
        return image;
    }

private:
    void DFS(vector<vector<int>>& image, int sr, int sc, int color, int old_color){
        int m = image.size();
        int n = image[0].size();
        if(sr < 0 || sc < 0 || sr >= m || sc >= n) return ;
        // 注意别Stack Overflow
        if(image[sr][sc] != old_color) return;
        // 自己
        image[sr][sc] = color;
        // 上下左右
        DFS(image, sr - 1, sc, color, old_color);
        DFS(image, sr + 1, sc, color, old_color);
        DFS(image, sr, sc - 1, color, old_color);
        DFS(image, sr, sc + 1, color, old_color);
    }
};
```

[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/description/)

DFS版本

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        // 深度遍历思想，沉岛法
        int count = 0;
        int m = grid.size(), n = grid[0].size();
        // 遍历整个grid
        for(int i = 0; i < m ; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == '1') {
                    count++;
                    DFS(grid, i, j);
                }
            }
        }
        return count;
    }
private:
    void DFS(vector<vector<char>>& grid, int r, int c){
        int m = grid.size(), n = grid[0].size();
        if(r < 0 || c < 0 || r >= m || c >= n) return;
        if(grid[r][c] == '0') return;
        grid[r][c] = '0';
        DFS(grid, r + 1, c);
        DFS(grid, r - 1, c);
        DFS(grid, r, c + 1);
        DFS(grid, r, c - 1);
    }
};
```

[463. 岛屿的周长 - 力扣（LeetCode）](https://leetcode.cn/problems/island-perimeter/)

```cpp
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int row = grid.size(), col = grid[0].size();
        int edge = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 1){
                    DFS(grid, i, j, edge);
                    return edge;
                }
            }
        }
        return edge;
    }
private:
    void DFS(vector<vector<int>>& grid, int r, int c, int& edge){
        int row = grid.size(), col = grid[0].size();
        if(r < 0 || c < 0 || r >= row || c >= col) {
            edge++;
            return;
        }
        if(grid[r][c] == 0) {
            edge += 1;
            return;
        }
        if(grid[r][c] == 2) return;
        grid[r][c] = 2;
        DFS(grid, r + 1, c, edge);
        DFS(grid, r - 1, c, edge);
        DFS(grid, r, c + 1, edge);
        DFS(grid, r, c - 1, edge);
    }
};
```

[417. 太平洋大西洋水流问题 - 力扣（LeetCode）](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

反向思维，标准的“多源 DFS/BFS”思想

```cpp
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();
        // 反向思维，生成一张能流向太平洋和大西洋的表
        // 标准的“多源 DFS/BFS”思想。
        vector<vector<bool>> pacific(m, vector<bool>(n, false));
        vector<vector<bool>> atlantic(m, vector<bool>(n, false));
        for(int i = 0; i < n; i++) {
            pacific[0][i] = true;
            DFS(heights, pacific, 1, i, heights[0][i]);
            atlantic[m - 1][i] = true;
            DFS(heights, atlantic, m - 2, i, heights[m - 1][i]);
        }
        for(int i = 0; i < m; i++){
            pacific[i][0] = true;
            DFS(heights, pacific, i, 1, heights[i][0]);
            atlantic[i][n - 1] = true;
            DFS(heights, atlantic, i, n - 2, heights[i][n - 1]);
        }
        vector<vector<int>> result;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(pacific[i][j] && atlantic[i][j]) result.push_back({i, j});
            }
        }
        return result;
    }
private:
    void DFS(vector<vector<int>>& heights, vector<vector<bool>>& ocean, int r, int c, int val){
        int m = heights.size();
        int n = heights[0].size();
        if(r < 0 || c < 0 || r >= m || c >= n) return;
        int cur_val = heights[r][c];
        if(cur_val >= val && ocean[r][c] == false){
            ocean[r][c] = true;
            DFS(heights, ocean, r + 1, c, cur_val);
            DFS(heights, ocean, r - 1, c, cur_val);
            DFS(heights, ocean, r, c + 1, cur_val);
            DFS(heights, ocean, r, c - 1, cur_val);
        }
    }
};
```

更优雅的做法：

```cpp
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();
        // 反向思维，生成一张能流向太平洋和大西洋的表
        // 标准的“多源 DFS/BFS”思想。
        vector<vector<bool>> pacific(m, vector<bool>(n, false));
        vector<vector<bool>> atlantic(m, vector<bool>(n, false));
        for(int i = 0; i < n; i++) {
            DFS(heights, pacific, 0, i);
            DFS(heights, atlantic, m - 1, i);
        }
        for(int i = 0; i < m; i++){
            DFS(heights, pacific, i, 0);
            DFS(heights, atlantic, i, n - 1);
        }
        vector<vector<int>> result;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(pacific[i][j] && atlantic[i][j]) result.push_back({i, j});
            }
        }
        return result;
    }
private:
    void DFS(vector<vector<int>>& heights, vector<vector<bool>>& ocean, int r, int c){
        if(ocean[r][c]) return;

        ocean[r][c] = true;

        int m = heights.size();
        int n = heights[0].size();

        // 方向数组，方便写循环（工程上常用技巧）
        int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        for(auto& d: dirs){
            int new_r = r + d[0];
            int new_c = c + d[1];

            // 越界检查和核心条件检查，挪到了递归之前
            if(new_r >= 0 && new_r < m && new_c >= 0 && new_c < n){
                if(heights[new_r][new_c] >= heights[r][c]){
                    DFS(heights, ocean, new_r, new_c);
                }
            }
        }
    }
};
```

[547. 省份数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-provinces/description/)

**为什么这道题DFS比BFS时空性能要好？**

1. 核心原因：工具的“重量”不同

我们可以把 DFS 和 BFS 想象成两个快递员：

- **DFS（深度优先）：轻装上阵的“跑酷选手”**
  - 它使用的是**系统栈（System Stack）**。这是操作系统底层直接支持的，极其高效。
  - **递归调用**在计算机底层就是简单的指令跳转和指针移动，开销非常小。
  - **比喻：** DFS 就像空着手跑步，跑到哪算哪，回溯时原路返回，动作极快。
- **BFS（广度优先）：推着购物车的“采购员”**
  - 它必须依赖一个**数据结构：队列（`std::queue`）**。
  - 在 C++ STL 中，`queue` 是一个复杂的对象（通常底层是 `deque`）。当你执行 `q.push()` 和 `q.pop()` 时，计算机需要在堆内存（Heap）里申请空间、管理指针、复制数据。
  - **比喻：** BFS 就像推着一个购物车（队列）。每到一个节点，都要把它的邻居抱起来放进车里，或者把人从车里抱出来。**“管理这辆车”的操作本身，比跑步要慢。**

**结论：** 在节点数（$N$）比较小的时候（这道题 $N \le 200$），BFS 维护队列的“固定开销”占比就很大，显得比 DFS 慢。

2. 数据结构的锅：邻接矩阵 vs 邻接表

这道题给的数据是**邻接矩阵**（二维数组），这对 BFS 来说有点“吃亏”。

- **BFS 的优势** 通常在于处理**稀疏图**（点很多，边很少），能快速扩散。
- **但这道题：** 不管是 BFS 还是 DFS，对于每一个城市，都必须把一行 `0` 到 `n-1` 的格子全部遍历一遍，才能知道谁连着谁。
  - 也就是说，算法的**时间复杂度瓶颈**其实卡在“遍历那一行数组”上，大家都是 $O(n^2)$。
  - 既然主任务（遍历数组）大家速度一样，那么 BFS 多出来的那个“维护队列”的动作，就成了拖后腿的因素。

3. 空间复杂度的真相

- **DFS：** 空间取决于**递归深度**。最坏情况是一条线（$O(n)$），最好情况是个星型图（$O(1)$，因为瞬间就回溯了）。
- **BFS：** 空间取决于**队列最宽的时候**。这道题如果是每个人都认识每个人（完全图），队列里可能一下子塞进去 $N-1$ 个节点。

更重要的是，`std::queue` 在内存中分配可能会产生碎片，而 DFS 的系统栈是连续内存，对 CPU 的**缓存（Cache）**更友好，读取速度更快。

DFS模板

```cpp
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        int num = 0;
        vector<bool> visited(n, false);
        // 邻接矩阵，通用的求联通分量模板写法
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                DFS(isConnected, visited, i);
                num++;
            }
        }
        return num;
    }
private:
    void DFS(vector<vector<int>>& isConnected, vector<bool>& visited, int k){
        int n = isConnected.size();
        visited[k] = true;
        for(int i = 0; i < n; i++){
            if(isConnected[k][i] == 1 && !visited[i]) DFS(isConnected, visited, i);
        }
    }
};
```

BFS模板

```cpp
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        int num = 0;
        vector<bool> visited(n, false);
        // 邻接矩阵，通用的求联通分量模板写法
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                DFS(isConnected, visited, i);
                num++;
            }
        }
        return num;
    }
private:
    void DFS(vector<vector<int>>& isConnected, vector<bool>& visited, int k){
        int n = isConnected.size();
        visited[k] = true;
        queue<int> q;
        q.push(k);
        while(!q.empty()){
            int cur = q.front();
            q.pop();
            for(int i = 0; i < n; i++){
                if(isConnected[cur][i] == 1 && !visited[i]){
                    q.push(i);
                    visited[i] = true;
                }
            }
        }
    }
};
```

[542. 01 矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/01-matrix/description/)

```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        // 水波纹模型，先让所有0入列
        int m = mat.size(), n = mat[0].size();
        vector<vector<int>> res(m, vector<int>(n, 0));
        queue<pair<int,int>> que;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(mat[i][j] == 0) que.push({i, j}); 
                else res[i][j] = -1; // 替代visited
            }
        }
        // 多源BFS，一层一层入列出列
        while(!que.empty()){
            auto p = que.front();
            que.pop();
            int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
            for(auto d : dir){
                int x = p.first + d[0];
                int y = p.second + d[1];
                if(x < 0 || x >= m || y < 0 || y >= n) continue;
                if(res[x][y] != -1) continue;
                res[x][y] = res[p.first][p.second] + 1;
                que.push({x, y});
            }
        }
        return res;
    }
};
```

[994. 腐烂的橘子 - 力扣（LeetCode）](https://leetcode.cn/problems/rotting-oranges/description/)

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        // 多源BFS
        int max_minutes = 0;
        // 统计还剩多少个好橘子
        int fresh_count = 0;
        int m = grid.size(), n = grid[0].size();
        queue<pair<int,int>> que;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 2) que.push({i, j});
                else if(grid[i][j] == 1) fresh_count++;
            }
        }
        while(!que.empty()){
            int size = que.size(); // 一次统计一层用
            bool infect = false;

            for(int i = 0; i < size; i++){
                auto p = que.front();
                que.pop();

                static int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 优化，静态变量

                for(auto d : dir){
                    int x = p.first + d[0];
                    int y = p.second + d[1];
                    if(x < 0 || x >= m || y < 0 || y >= n) continue;
                    if(grid[x][y] != 1) continue;
                    grid[x][y] = 2;
                    infect = true;
                    fresh_count--;
                    que.push({x, y});
                }
            }
            // 这一层都遍历完了加1分钟
            if(infect) max_minutes++;
        }
        
        return fresh_count == 0 ? max_minutes : -1;
    }
};
```

[127. 单词接龙](https://leetcode.cn/problems/word-ladder/description/)

BFS：

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        int n = wordList.size();
        vector<bool> visited(n, false);
        queue<string> que;
        que.push(beginWord);
        int step = 1;
        // 找到位置
        int pos = -1;
        for(int i = 0; i < n; i++){
            if(wordList[i] == endWord) {
                pos = i;
                break;
            }
        }
        if(pos == -1) return 0;

        // 图论BFS
        while(!que.empty()){
            // 一层一层数
            int size = que.size(); 
            for(int i = 0; i < size; i++){
                for(int j = 0; j < n; j++){
                    if(!visited[j]){
                        visited[j] = nextWord(que.front(), wordList[j]);
                        if(visited[j]) {
                            // 剪枝别忘了
                            if(wordList[j] == endWord) return step + 1;
                            que.push(wordList[j]);
                        }
                    }
                }
                que.pop(); // 注意把字符串的后续字符串都找干净再pop
            }
            step++;
        }
        // 如果没找到或者刚好是最后一步
        return visited[pos] ? step : 0;
    }
private:
    int nextWord(string &curWord, string &diffWord){
        int diff = 0;
        for(int i = 0; i < curWord.size(); i++){
            if(curWord[i] != diffWord[i]) diff++;
            if(diff > 1) return false;
        }
        return diff == 1;
    }
};
```

时间性能压缩到极致的做法：

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        int n = wordList.size();
        int step = 1;
        // 把 vector 转成 unordered_set，查找速度从 O(N) 变成 O(1)
        unordered_set<string> dict(wordList.begin(), wordList.end());

        // 如果 endWord 根本不在字典里，直接返回 0
        if (dict.find(endWord) == dict.end()) return 0;

        queue<string> que;
        que.push(beginWord);

        // 小技巧：直接在 dict 中删除访问过的词，省去 visited 数组的空间和维护成本
        if(dict.count(beginWord)) dict.erase(beginWord);

        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                string curWord = que.front();
                que.pop();

                for(int j = 0; j < curWord.size(); j++){
                    // 暂存原来的字符
                    char originalChar = curWord[j]; 

                    // 尝试把这个位置替换成 a-z
                    for(char k = 'a'; k <= 'z'; k++){
                        if(k == originalChar) continue;
                        curWord[j] = k;
                        if(curWord == endWord) return step + 1;
                        if(dict.count(curWord)){
                            que.push(curWord);
                            dict.erase(curWord);
                        }
                    }

                    // 还原字符，准备变换下一个位置
                    curWord[j] = originalChar;
                }
            }
            step++;
        }
        return 0;
    }
};
```

[207.课程表](https://leetcode.cn/problems/course-schedule/description/)

拓扑排序模板题

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 拓扑排序做法？我为什么感觉我在写BFS

        // 建图
        // 入度
        vector<int> indegree(numCourses, 0);
        // 邻接表
        vector<vector<int>> gragh(numCourses);
        for(auto& p : prerequisites){
            indegree[p[0]] ++;
            // 前置课程->[...后续课程]
            gragh[p[1]].push_back(p[0]);
        }

        // 建队列
        queue<int> que;
        for(int i = 0; i < numCourses; i++){ // 在队列中注入入度为0的节点
            if(indegree[i] == 0) que.push(i);
        }
        int count = 0; // 记录当前已经输出的节点数

        while(!que.empty()){
            int cur = que.front();
            que.pop();
            count++;
            for(int k : gragh[cur]){
                indegree[k]--;
                if(indegree[k] == 0) que.push(k);
            }
        }
        return count == numCourses;
    }
};
```

dfs写法，主要是看有没有环

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 1. 建图
        graph.resize(numCourses);
        visited.resize(numCourses, 0);

        for (auto& p : prerequisites) {
            graph[p[1]].push_back(p[0]); // p[1] -> p[0]
        }

        // 2. 对每个节点进行 DFS（防止图是不连通的）
        for (int i = 0; i < numCourses; i++) {
            if (valid && visited[i] == 0) {
                dfs(i);
            }
        }

        return valid;
    }

private:
    vector<int> visited;
    vector<vector<int>> graph;
    bool valid = true;

    void dfs(int u){
        // 如果已经发现有环，直接停止后续搜索，节省时间
        if (!valid) return;

        visited[u] = 1; // 标记为“正在访问”

        for(int v : graph[u]){
            if(visited[v] == 0){
                // 如果没访问过，继续深挖
                dfs(v);
                if(!valid) return;
            } else if(visited[v] == 1){
                // 如果没访问过，继续深挖
                valid = false;
                return;
            }
            // 如果 visited[v] == 2，说明是安全的，不用管
        }

        visited[u] = 2; // 标记为“已完成”
    }
};
```

[210. 课程表2][https://leetcode.cn/problems/course-schedule-ii/description/]

```cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        // 拓扑排序BFS
        vector<int> res;
        res.reserve(numCourses); // 【优化B】避免动态扩容搬运
        vector<int> indegree(numCourses, 0);
        vector<vector<int>> graph(numCourses);
        queue<int> que;

        // 初始化
        for(auto &p : prerequisites) {
            indegree[p[0]]++;
            graph[p[1]].push_back(p[0]);
        }

        for(int i = 0; i < numCourses; i++){
            if(indegree[i] == 0) que.push(i);
        }

        while(!que.empty()){
            int cur = que.front();
            que.pop();
            res.push_back(cur);

            for(int p : graph[cur]){
                indegree[p]--;
                if(indegree[p] == 0) que.push(p);
            }
        }

        if (res.size() == numCourses) return res;
        return {};
    }
};
```

[802. 找到最终的安全状态 - 力扣（LeetCode）](https://leetcode.cn/problems/find-eventual-safe-states/description/)

反向BFS

```cpp
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        // 反向DFS，维护outdegree
        int n = graph.size();
        vector<int> outdegree;
        outdegree.reserve(n);
        for(auto &o : graph) outdegree.push_back(o.size());

        // 构建入度邻接表
        vector<vector<int>> in_graph(n);
        for(int i = 0; i < n; i++){
            for(int o : graph[i]){
                in_graph[o].push_back(i); 
            }
        }

        // 初始化队列
        queue<int> que;
        for(int i = 0; i < n; i++){
            if(outdegree[i] == 0) que.push(i);
        }

        // BFS遍历
        vector<int> res;
        res.reserve(n);
        while(!que.empty()){
            int cur = que.front();
            res.push_back(cur);
            que.pop();

            for(int i : in_graph[cur]){
                outdegree[i]--;
                if(outdegree[i] == 0){
                    que.push(i);
                }
            }
        }

        sort(res.begin(), res.end(), [](int a, int b){
            return a < b;
        });
        return res;
    }
};
```

DFS染色法

```cpp
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        // 反向DFS
        int n = static_cast<int>(graph.size());
        vector<int> res;
        res.reserve(n);

        vector<int> color(n, 0);
        for(int i = 0; i < n; i++){
            if(DFS(graph, color, i)){
                res.push_back(i);
            }
        }

        sort(res.begin(), res.end(), [](int a, int b){
            return a < b;
        });
        return res;
    }
private:
    // 0是未访问，1是正在访问，2是安全节点，3是不安全节点
    bool DFS(vector<vector<int>>& graph, vector<int>& color, int u){
        if(color[u] == 2) return true;
        if(color[u] == 1) return false;
        if(color[u] == 3) return false;

        color[u] = 1; //入栈

        // DFS遍历邻居
        for(int v : graph[u]){
            if(!DFS(graph, color, v)){
                color[u] = 3;
                return false;
            }
        }

        color[u] = 2;
        return true;
    }
};
```

[310. 最小高度树 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-height-trees/description/)

无向图BFS

```cpp
class Solution {
public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        // 反向BFS
        // 构建邻接表
        if(n == 1) return {0};

        vector<vector<int>> graph(n);
        vector<int> degree(n);
        for(const auto &e : edges){
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
            degree[e[0]]++;
            degree[e[1]]++;
        }

        // 构建队列
        queue<int> que;
        for(int i = 0; i < n; ++i){
            if(degree[i] == 1) que.push(i);
        }

        // BFS
        int remain = n; // 中心结点数量只能是1或2
        while(remain > 2){
            int size = que.size();
            remain -= size; // 减去这一轮出栈的数量
            for(int i = 0; i < size; ++i){
                int cur = que.front();
                que.pop();
                for(int e : graph[cur]){
                    degree[e]--;
                    if(degree[e] == 1){
                        que.push(e);
                    }
                }
            }
        }

        vector<int> res(remain);
        for(int i = 0; i < remain; ++i){
            res[i] = que.front();
            que.pop();
        }

        return res;
    }
};
```

[684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)

并查集

```cpp
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        // 初始化，开大一点防止访问越界（误报为爆栈）
        int n = 1005;
        vector<int> parent(n);
        for(int i = 0; i < n; ++i) parent[i] = i;

        for(const auto& edge : edges){
            int u = edge[0];
            int v = edge[1];

            // 返回最后一个边
            if(!join(u, v, parent)) return edge;
        }

        return {};
    }
private:
    // 查找节点，路径压缩
    int find(int u, vector<int>& parent){
        if(parent[u] == u) return u;
        parent[u] = find(parent[u], parent);
        return parent[u];
    }
    // 集合合并，判断是否在一个集合
    bool join(int u, int v, vector<int>& parent){
        int rootU = find(u, parent);
        int rootV = find(v, parent);

        // 在一个集合
        if(rootU == rootV) return false;

        // 不在一个集合
        parent[rootV] = rootU;
        return true;
    }
};
```

[1319. 连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)

```cpp
class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        // 并查集应用
        vector<int> parent(n, 0);
        int count = n; // 联通子图个数
        int extra_edge = 0;
        for(int i = 0; i < n; i++) parent[i] = i;

        for(const auto& c : connections){
            if(join(c[0], c[1], parent)){
                // 若未联通，联通后联通子图减1
                count--;
            }
            // 找到多余的边，不管这个边是什么就能安排到任意两个联通子图之间。
            else extra_edge++;
        }

        int res = count - extra_edge;
        if(res <= 1) return count - 1;
        else return -1; 
    }
private:
    bool join(int u, int v, vector<int>& parent){
        int rootU = find(u, parent);
        int rootV = find(v, parent);
        if(rootU == rootV) {
            // 找到多余的边
            return false;
        }
        
        parent[rootU] = rootV;
        return true;
    }

    int find(int u, vector<int>& parent){
        if(u == parent[u]) return u;

        parent[u] = find(parent[u], parent);
        return parent[u];
    }
};
```

[990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

```cpp
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        // 并查集思想：!=是不能在一个连通子图里边
        vector<int> parent(26, 0);
        iota(parent.begin(), parent.end(), 0);

        for(int i = 0; i < equations.size(); i++){
            string& str =  equations[i];
            int first = str[0] - 'a', second = str[3] - 'a';
            if(str[1] == '=') {
                join(first, second, parent);
            }
        }

        for(int i = 0; i < equations.size(); i++){
            string& str =  equations[i];
            int first = str[0] - 'a', second = str[3] - 'a';
            if(str[1] == '!') {
                if(find(first, parent) == find(second, parent)){
                    return false;
                }
            }
        }

        return true;
    }

private:
    int find(int u, vector<int>& parent){
        if(u == parent[u]) return u;

        parent[u] = find(parent[u], parent);
        return parent[u];
    }
    bool join(int u, int v, vector<int>& parent){
        int rootU = find(u, parent);
        int rootV = find(v, parent);
        if(rootU == rootV) return false;

        parent[rootU] = rootV;
        return true;
    }
    
};
```

[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

```cpp
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        //dijkstra
        
        // 构建有向图的邻接表
        vector<vector<pair<int, int>>> graph(n + 1);
        for(const auto& t : times){
            graph[t[0]].push_back({t[1], t[2]});
        }

        // 构建dist数组
        vector<int> dist(n + 1, INT_MAX);
        dist[k] = 0;

        // 构建小根堆
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, k}); // [时间，节点]

        while(!pq.empty()){
            auto [d, u] = pq.top();
            pq.pop();
            
            // 如果从堆里边取出的时间已经小于我们找到的最短路径，直接扔掉就可以（废弃路径）
            if(d > dist[u]) continue;

            // 遍历节点U的所有邻居
            for(auto& edge : graph[u]){
                int v = edge.first; // 下一个节点
                int w = edge.second; // 路径

                // 如果 "起点->u->v" 比 "已知的起点->v" 更快，就更新
                if(dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    pq.push({dist[v], v}); // 把新的更短路径推入队列
                }
            } 
        }

        int maxTime = 0;
        for(int i = 1; i <= n; i++){
            if(dist[i] == INT_MAX) return -1;
            maxTime = max(maxTime, dist[i]);
        }

        return maxTime;
    }
};
```

[1514. 概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/)

```cpp
class Solution {
public:
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {
        // Dijkstra
        // 邻接矩阵
        vector<vector<pair<int, double>>> graph(n);
        for(int i = 0; i < edges.size(); i++){
            // 出发点 -> {结束点，概率}
            auto e = edges[i];
            graph[e[0]].push_back({e[1], succProb[i]});
            graph[e[1]].push_back({e[0], succProb[i]});
        }

        // dist
        vector<double> dist(n, 0);
        dist[start_node] = 1;

        // 大根堆
        priority_queue<pair<double, int>, vector<pair<double, int>>> pq;
        pq.push({1.0 , start_node}); // 概率，节点

        while(!pq.empty()){
            auto [p, n] = pq.top();
            pq.pop();

            // 废弃路径
            if(p < dist[n]) continue;

            // 遍历邻居
            for(const auto& g : graph[n]){
                double np = p * g.second;
                int v = g.first;
                if(np > dist[v]){
                    dist[v] = np;
                    pq.push({np, v});
                }
            }
        }
        return dist[end_node];
    }
};
```

[787. K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)

dijkstra做法

```cpp
class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        // dijkstra
        vector<vector<pair<int, int>>> graph(n);
        for(const auto& f : flights){
            graph[f[0]].push_back({f[1], f[2]}); // 起始节点 -> {终点，花费}
        }

        vector<int> dist(n, 0);

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, src, 0}); // {花费，起始节点，步数}

        // 剪枝数组，记录到达节点i时历史上用了多少次中转
        // 如果下次再到 i，花费更大且中转次数更多，那就绝对是废路
        vector<int> min_steps(n, INT_MAX);


        while(!pq.empty()){
            auto vec = pq.top();
            int cost = vec[0];
            int node = vec[1];
            int step = vec[2];
            pq.pop();

            // 剪枝1：根据步数剪枝，k次中转是k + 1条边
            if(step > k + 1) continue;

            // 小根堆特性，满足步数要求后，当遍历到终点时一定是最小值
            if(node == dst) return cost;

            // 剪枝2：中转次数满足条件下，根据小根堆特性，弹出来的一定比之前的花费大
            // 花费更大且中转次数更多，那就绝对是废路
            if(step >= min_steps[node]) continue;

            // 更新该点的历史最优步数
            min_steps[node] = step;

            for(const auto& g : graph[node]){
                auto [nNode, nCost] = g;
                // 这里不用再比较cost了
                pq.push({cost + nCost, nNode, step + 1});
            }
        }

        return -1;
    }
};
```

Bellman-Ford做法

```cpp
class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        // Bellman-Ford 有权图的BFS 时间复杂度O(V * E)

        //初始化距离数组，大家都是无穷大
        vector<int> dist(n, INT_MAX);
        dist[src] = 0;

        // 核心循环，只能走k + 1次（对应k次中转）
        for(int i = 0; i <= k; i++){
            auto temp = dist;

            // 遍历所有的边 (不像Dijkstra只遍历邻居，这里是很笨的遍历所有边)
            for(const auto& f : flights){
                int u = f[0], v = f[1], w = f[2];

                // 只有起点被访问到了，才能更新
                if(dist[u] != INT_MAX){
                    temp[v] = min(temp[v], dist[u] + w);
                }
            }

            // 更新状态
            dist = temp;
        }

        return dist[dst] == INT_MAX ? -1 : dist[dst];
    }
};
```

[1584. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

```cpp
class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {

        int n = points.size();
        vector<int> minDist(n, INT_MAX);
        vector<bool> visited(n, false);

        minDist[0] = 0;
        int totalCost = 0;

        for(int i = 0; i < n; i++){
            int curMin = INT_MAX;
            int u = -1;

            for(int j = 0; j < n; j++){
                if(!visited[j] && minDist[j] < curMin){
                    curMin = minDist[j];
                    u = j;
                }
            }

            visited[u] = true;
            totalCost += curMin;

            for(int j = 0; j < n; j++){
                if(!visited[j]){
                    int dist = abs(points[u][0] - points[j][0]) + abs(points[u][1] - points[j][1]);

                    if(dist < minDist[j]){
                        minDist[j] = dist;
                    }
                }
            }
        }

        return totalCost;
    }
};
```

