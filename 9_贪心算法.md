# 9_贪心算法

[455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/)

我自己写的大-大策略

```cpp
class Solution {
private:
    static bool compare(int a, int b) {
        return a > b; // 降序排列
    }
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        if(s.size() == 0) return 0;
        int res = 0;
        int i = 0;
        
        sort(g.begin(), g.end(), compare);
        sort(s.begin(), s.end(), compare);

        for(int cookie : s){
            for(;i < g.size(); i++){
                if(cookie >= g[i]){
                    res++;
                    break;
                }
                else continue;
            }
            if(i == g.size() - 1) break;
            i++;
        }

        return res;
    }
};
```

**补充：为什么我在private里在定义compare时如果不加上static，那么在public中的sort使用compare会报错？**

因为非 `static` 成员函数在被调用时，编译器会偷偷地给它传递一个额外的、隐藏的参数，就是 `this` 指针，它指向调用这个函数的对象。

所以，编译器眼中的 `compare` 函数签名，实际上更像是：

```cpp
// 编译器“想象”中的样子
bool compare(Solution* this, int a, int b) { 
    return a > b; 
}
```

而实际上sort最后的参数函数仅需要两个变量。

[2410. 运动员和训练师的最大匹配数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/description/)

小-小策略

```cpp
class Solution {
public:
    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {
        // 小-小策略
        sort(players.begin(), players.end());
        sort(trainers.begin(), trainers.end());
        int i = 0, j = 0;
        int res = 0;

        while(i < players.size() && j < trainers.size()){
            if(players[i] <= trainers[j]){
                res++;
                i++;
                j++;
            }
            else j++;
        }

        return res;
    }
};
```

[1005. K 次取反后最大化的数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

性能很差的解法：

```cpp
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        for(int i = 1; i <= k; i++){
            nums[0] = -nums[0];
            sort(nums.begin(), nums.end());
        }
        int sum = 0;
        for(int i : nums) sum += i;
        return sum;
    }
};
```

按照绝对值排序的解法，这样就不用每次改完数字都再排列一遍了

```cpp
class Solution {
private:
    static bool cmp(int a , int b){
        // 按照元素绝对值降序排序
        return abs(a) > abs(b);
    }
    static int sum(vector<int>& nums){
        int summary = 0;
        for(int i = 0; i < nums.size(); i++) summary += nums[i];
        return summary;
    }
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp);
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] < 0) {
                nums[i] = -nums[i];
                k--;
            }
            if(k == 0) return sum(nums);
        }
        if(k % 2 == 0) return sum(nums);
        nums[nums.size() - 1] = -nums[nums.size() - 1];
        return sum(nums);
    }
};
```

[860. 柠檬水找零 - 力扣（LeetCode）](https://leetcode.cn/problems/lemonade-change/)

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        unordered_map<int, int> cash;
        for(int b : bills){
            cash[b]++;
            if(b == 20){
                if(cash[10] >= 1 && cash[5] >= 1) {
                    cash[10]--;
                    cash[5]--;
                }
                else if(cash[5] >= 3) cash[5] -= 3;
                else return false;
            }
            else if(b == 10){
                if(cash[5] >= 1) cash[5]--;
                else return false;
            }
        }
        return true;
    }
};
```

