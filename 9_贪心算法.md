# 9_贪心算法

### 简单题

[455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/)

我自己写的大-大策略

```cpp
class Solution {
private:
    static bool compare(int a, int b) {
        return a > b; // 降序排列
    }
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        if(s.size() == 0) return 0;
        int res = 0;
        int i = 0;
        
        sort(g.begin(), g.end(), compare);
        sort(s.begin(), s.end(), compare);

        for(int cookie : s){
            for(;i < g.size(); i++){
                if(cookie >= g[i]){
                    res++;
                    break;
                }
                else continue;
            }
            if(i == g.size() - 1) break;
            i++;
        }

        return res;
    }
};
```

**补充：为什么我在private里在定义compare时如果不加上static，那么在public中的sort使用compare会报错？**

因为非 `static` 成员函数在被调用时，编译器会偷偷地给它传递一个额外的、隐藏的参数，就是 `this` 指针，它指向调用这个函数的对象。

所以，编译器眼中的 `compare` 函数签名，实际上更像是：

```cpp
// 编译器“想象”中的样子
bool compare(Solution* this, int a, int b) { 
    return a > b; 
}
```

而实际上sort最后的参数函数仅需要两个变量。

[2410. 运动员和训练师的最大匹配数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/description/)

小-小策略

```cpp
class Solution {
public:
    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {
        // 小-小策略
        sort(players.begin(), players.end());
        sort(trainers.begin(), trainers.end());
        int i = 0, j = 0;
        int res = 0;

        while(i < players.size() && j < trainers.size()){
            if(players[i] <= trainers[j]){
                res++;
                i++;
                j++;
            }
            else j++;
        }

        return res;
    }
};
```

[1005. K 次取反后最大化的数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

性能很差的解法：

```cpp
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        for(int i = 1; i <= k; i++){
            nums[0] = -nums[0];
            sort(nums.begin(), nums.end());
        }
        int sum = 0;
        for(int i : nums) sum += i;
        return sum;
    }
};
```

按照绝对值排序的解法，这样就不用每次改完数字都再排列一遍了

```cpp
class Solution {
private:
    static bool cmp(int a , int b){
        // 按照元素绝对值降序排序
        return abs(a) > abs(b);
    }
    static int sum(vector<int>& nums){
        int summary = 0;
        for(int i = 0; i < nums.size(); i++) summary += nums[i];
        return summary;
    }
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp);
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] < 0) {
                nums[i] = -nums[i];
                k--;
            }
            if(k == 0) return sum(nums);
        }
        if(k % 2 == 0) return sum(nums);
        nums[nums.size() - 1] = -nums[nums.size() - 1];
        return sum(nums);
    }
};
```

[860. 柠檬水找零 - 力扣（LeetCode）](https://leetcode.cn/problems/lemonade-change/)

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        unordered_map<int, int> cash;
        for(int b : bills){
            cash[b]++;
            if(b == 20){
                if(cash[10] >= 1 && cash[5] >= 1) {
                    cash[10]--;
                    cash[5]--;
                }
                else if(cash[5] >= 3) cash[5] -= 3;
                else return false;
            }
            else if(b == 10){
                if(cash[5] >= 1) cash[5]--;
                else return false;
            }
        }
        return true;
    }
};
```

### 中等题

[376. 摆动序列 - 力扣（LeetCode）](https://leetcode.cn/problems/wiggle-subsequence/)

自己写的回溯算法超时了

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        vector<int> path(1, nums[0]); // 假设第一个元素总在序列中
        backtracking(nums, path, 0, true);
        return res;    
    }
private:
    int res = 1; // 至少序列长度为1
    void backtracking(vector<int>& nums, vector<int>& path, int cur, bool sub){
        if(cur == nums.size() - 1){
            if(res < path.size()) res = path.size();
            return;
        }
        for(int i = cur + 1; i < nums.size(); i++){
            int s = nums[cur] - nums[i];
            if(s == 0) continue;
            // 当前元素小于后面的指定元素时为false，大于为true
            bool curSub = s > 0 ? true : false; 
            if(cur == 0 || sub && !curSub || !sub && curSub){
                path.push_back(nums[i]);
                backtracking(nums, path, i, curSub);
                path.pop_back();
            }
        }
    }
};
```

贪心解法，时间复杂度为O(n):

```cpp
class Solution {
public:
    // 我们要找的是“最长”的摆动序列，我们不需要关心子序列里具体的数值，只需要关心序列中有多少个“拐点”（即波峰和波谷）。
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() == 1) return 1;

        int length = 1;
        int diffPre = 0;
        int diffCur = 0;
        for(int i = 1; i < nums.size(); i++){
            diffCur = nums[i] - nums[i - 1];
            if(diffCur > 0 && diffPre <= 0 || diffCur < 0 && diffPre >= 0) length++;
            // 如果 curdiff == 0 (持平)，prediff 保持原来的状态，继续寻找下一个拐点
            if (diffCur != 0) {
                diffPre = diffCur;
            }
        }

        return length;
    }
};
```

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

正确的 $O(n)$ 贪心/动态规划思路 (Kadane 算法)

这个算法之所以广为人知，是因为它非常巧妙地将时间复杂度从 $O(n^2)$（朴素的暴力枚举）优化到了 $O(n)$。

核心思想：“要么加入，要么重来。”

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = nums[0];
        int cur = res;
        for(int i = 1; i < nums.size(); i++){
            // 当前窗口的总和小于等于零时，直接替换。
            if(cur <= 0) cur = nums[i];
            // 当前窗口的总和大于零时，直接加。
            else if(cur > 0) cur += nums[i];
            if(cur > res) res = cur;
        }
        return res;
    }
};
```

