# 9_贪心算法

### 简单题

[455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/)

我自己写的大-大策略

```cpp
class Solution {
private:
    static bool compare(int a, int b) {
        return a > b; // 降序排列
    }
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        if(s.size() == 0) return 0;
        int res = 0;
        int i = 0;
        
        sort(g.begin(), g.end(), compare);
        sort(s.begin(), s.end(), compare);

        for(int cookie : s){
            for(;i < g.size(); i++){
                if(cookie >= g[i]){
                    res++;
                    break;
                }
                else continue;
            }
            if(i == g.size() - 1) break;
            i++;
        }

        return res;
    }
};
```

**补充：为什么我在private里在定义compare时如果不加上static，那么在public中的sort使用compare会报错？**

因为非 `static` 成员函数在被调用时，编译器会偷偷地给它传递一个额外的、隐藏的参数，就是 `this` 指针，它指向调用这个函数的对象。

所以，编译器眼中的 `compare` 函数签名，实际上更像是：

```cpp
// 编译器“想象”中的样子
bool compare(Solution* this, int a, int b) { 
    return a > b; 
}
```

而实际上sort最后的参数函数仅需要两个变量。

[2410. 运动员和训练师的最大匹配数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/description/)

小-小策略

```cpp
class Solution {
public:
    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {
        // 小-小策略
        sort(players.begin(), players.end());
        sort(trainers.begin(), trainers.end());
        int i = 0, j = 0;
        int res = 0;

        while(i < players.size() && j < trainers.size()){
            if(players[i] <= trainers[j]){
                res++;
                i++;
                j++;
            }
            else j++;
        }

        return res;
    }
};
```

[1005. K 次取反后最大化的数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

性能很差的解法：

```cpp
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        for(int i = 1; i <= k; i++){
            nums[0] = -nums[0];
            sort(nums.begin(), nums.end());
        }
        int sum = 0;
        for(int i : nums) sum += i;
        return sum;
    }
};
```

按照绝对值排序的解法，这样就不用每次改完数字都再排列一遍了

```cpp
class Solution {
private:
    static bool cmp(int a , int b){
        // 按照元素绝对值降序排序
        return abs(a) > abs(b);
    }
    static int sum(vector<int>& nums){
        int summary = 0;
        for(int i = 0; i < nums.size(); i++) summary += nums[i];
        return summary;
    }
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp);
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] < 0) {
                nums[i] = -nums[i];
                k--;
            }
            if(k == 0) return sum(nums);
        }
        if(k % 2 == 0) return sum(nums);
        nums[nums.size() - 1] = -nums[nums.size() - 1];
        return sum(nums);
    }
};
```

[860. 柠檬水找零 - 力扣（LeetCode）](https://leetcode.cn/problems/lemonade-change/)

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        unordered_map<int, int> cash;
        for(int b : bills){
            cash[b]++;
            if(b == 20){
                if(cash[10] >= 1 && cash[5] >= 1) {
                    cash[10]--;
                    cash[5]--;
                }
                else if(cash[5] >= 3) cash[5] -= 3;
                else return false;
            }
            else if(b == 10){
                if(cash[5] >= 1) cash[5]--;
                else return false;
            }
        }
        return true;
    }
};
```

### 中等题

[376. 摆动序列 - 力扣（LeetCode）](https://leetcode.cn/problems/wiggle-subsequence/)

自己写的回溯算法超时了

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        vector<int> path(1, nums[0]); // 假设第一个元素总在序列中
        backtracking(nums, path, 0, true);
        return res;    
    }
private:
    int res = 1; // 至少序列长度为1
    void backtracking(vector<int>& nums, vector<int>& path, int cur, bool sub){
        if(cur == nums.size() - 1){
            if(res < path.size()) res = path.size();
            return;
        }
        for(int i = cur + 1; i < nums.size(); i++){
            int s = nums[cur] - nums[i];
            if(s == 0) continue;
            // 当前元素小于后面的指定元素时为false，大于为true
            bool curSub = s > 0 ? true : false; 
            if(cur == 0 || sub && !curSub || !sub && curSub){
                path.push_back(nums[i]);
                backtracking(nums, path, i, curSub);
                path.pop_back();
            }
        }
    }
};
```

贪心解法，时间复杂度为O(n):

```cpp
class Solution {
public:
    // 我们要找的是“最长”的摆动序列，我们不需要关心子序列里具体的数值，只需要关心序列中有多少个“拐点”（即波峰和波谷）。
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() == 1) return 1;

        int length = 1;
        int diffPre = 0;
        int diffCur = 0;
        for(int i = 1; i < nums.size(); i++){
            diffCur = nums[i] - nums[i - 1];
            if(diffCur > 0 && diffPre <= 0 || diffCur < 0 && diffPre >= 0) length++;
            // 如果 curdiff == 0 (持平)，prediff 保持原来的状态，继续寻找下一个拐点
            if (diffCur != 0) {
                diffPre = diffCur;
            }
        }

        return length;
    }
};
```

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

正确的 $O(n)$ 贪心/动态规划思路 (Kadane 算法)

这个算法之所以广为人知，是因为它非常巧妙地将时间复杂度从 $O(n^2)$（朴素的暴力枚举）优化到了 $O(n)$。

核心思想：“要么加入，要么重来。”

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = nums[0];
        int cur = res;
        for(int i = 1; i < nums.size(); i++){
            // 当前窗口的总和小于等于零时，直接替换。
            if(cur <= 0) cur = nums[i];
            // 当前窗口的总和大于零时，直接加。
            else if(cur > 0) cur += nums[i];
            if(cur > res) res = cur;
        }
        return res;
    }
};
```

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 和摆动序列类似，找到极大极小值
        int res = 0;
        if(prices.size() == 1) return 0;
        int preDiff = 0, curDiff = 0, stock = prices[0];
        for(int i = 1; i < prices.size(); i++){
            curDiff = prices[i] - prices[i - 1];
            // 单调性不变时，不买卖股票
            // 找到极大值，卖出股票
            if(curDiff < 0 && preDiff > 0) {
                res += prices[i - 1] - stock;
                stock = -1;
            }
            // 找到极小值，买入股票
            else if(curDiff > 0 && preDiff < 0) stock = prices[i - 1];
            // 只有严格单调递增或递减时才更新参数 
            if(curDiff != 0) preDiff = curDiff;
        }
        // 在持有股票时，若股票在上涨或者停滞时结束，用最后一个股票减去最后入的股票
        if(curDiff >= 0 && stock >= 0) res += prices[prices.size() - 1] - stock;
        return res;
    }
};
```

更简单的方法：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res = 0;
        for(int i = 1; i < prices.size(); i++){
            int cur = prices[i] - prices[i - 1];
            if(cur > 0) res += cur;
        }
        return res;
    }
};
```

[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/)

非常烂的回溯写法（还问了哈基米）：

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 1) return true;
        bool res = false;
        vector<bool> visited(nums.size(), false); // 增加一个记忆化，防止重复搜索
        backtracking(0, nums, res, visited);
        return res;
    }
private:
    void backtracking(int cur, vector<int>& nums, bool& res, vector<bool>& visited){

        if(res || visited[cur]) return; // 如果已经到达终点或者这个节点已经找过且失败则返回。
        // 当前节点已访问
        visited[cur] = true;
        
        if(cur == nums.size() - 1) { // 检测是否到达终点
            res = true;
            return;
        }
        // i是步数，倒序跳越（剪枝优化）
        int max_jump = nums[cur];
        for(int i = max_jump; i >= 1; i--){
            // 当越界时直接跳过
            if(i + cur >= nums.size()) continue;
            // 找到终点
            if(i + cur == nums.size() - 1){
                res = true;
                return;
            }
            backtracking(i + cur, nums, res, visited);
            // 如果找到了立即返回
            if(res) return;
        }
    }
};
```

**回溯法在思考**：“我从 *这里* 出发，*能跳到* 哪些 *新位置*？”，它关心的是 **路径**。

**贪心法在思考**：“在所有 *我能到达* 的位置里，我 *最远能跳到* 哪里？”，它只关心 **最远能到达的边界**。

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        // 贪心算法：我们只关注最大下标能否到达
        int max_reach = 0;
        for(int i = 0; i < nums.size(); i++){
            if(i > max_reach) return false; // 若i到达不了那后面的更到不了
            max_reach = max(i + nums[i], max_reach); // 更新当前能到达最大下标的位置
            if(max_reach >= nums.size() - 1) return true;
        }
        // 其实没必要再返回。如果把上面那个if直接删掉能简化逻辑，因为循环正常结束所以要返回true
        return true;
    }
};
```

[45. 跳跃游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-ii/description/)

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size() == 1) return 0;
        int res = 0;
        int max_reach = 0;
        int current_end = 0; // 当前跳越的最远距离
        for(int i = 0; i < nums.size(); i++){
            max_reach = max(nums[i] + i, max_reach);
            if(i == current_end) {
                // 当i到达当前边界时
                res++;
                current_end = max_reach;
                if(current_end >= nums.size() - 1) break;
            }
        }
        return res;
    }
};
```

[134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/)

暴力算法，会超时：

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int cur = 0; // 当前油箱
        int curCost = 0; // 到下一站需要的油
        // 先试试暴力，第一层循环表示从哪里开始
        for(int i = 0; i < gas.size(); i++){
            cur = gas[i];
            curCost = cost[i];
            int j = (i + 1) % gas.size();
            while(true){
                if(cur - curCost < 0) break;
                if(j == i) return i;
                cur = cur - curCost + gas[j];
                curCost = cost[j];
                j++;
                if(j == gas.size()) j = 0;
            }
        }
        return -1;
    }
};
```

巧妙的贪心算法：

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int start = 0; // 可能的起点
        int curSum = 0; // 判断局部一段能否跑完
        int totalSum = 0; // 判断全局是否能跑完
        // 贪心：若局部能跑完则全局也能跑完
        int n = gas.size();
        for(int i = 0; i < n; i++){
            int diff = gas[i] - cost[i];
            curSum += diff;
            totalSum += diff;
            if(curSum < 0){
                start = i + 1;
                curSum = 0;
            }
        }
        // 题目中保证了只有一个解，如果不是没有解的情况则必然为start
        if(totalSum < 0) return -1;
        return start;
    }
};
```

[135. 分发糖果 - 力扣（LeetCode）](https://leetcode.cn/problems/candy/description/)

贪心的核心思想：先从一个方向满足约束，再从另一个方向满足约束，最后合并结果

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        // 我的直觉是需要维护一个存放分发糖果的数组
        vector<int> candyList(n, 1);
        // 核心思想：先从一个方向满足约束，再从另一个方向满足约束，最后合并结果
        // 第一遍遍历，只考虑和左边数的关系，如果比左边大就加1
        for(int i = 1; i < n; i++){
            if(ratings[i] > ratings[i - 1]) candyList[i] = candyList[i - 1] + 1;
        }
        // 第二遍遍历，只考虑和右边数的关系，如果比右边大就加1，注意是反着遍历的
        for(int i = n - 2; i >= 0; i--){
            // 注意这里需要同时满足两个规则故取max
            if(ratings[i] > ratings[i + 1]) candyList[i] = max(candyList[i + 1] + 1, candyList[i]);
        }
        int sum = 0;
        for(int i : candyList) sum += i;
        return sum;
    }
};
```

[406. 根据身高重建队列 - 力扣（LeetCode）](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)

和上道题很类似，都是把不同属性分开各自排好序

```cpp
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        // 按身高 h 降序（从高到矮）排列。
        // 如果身高 h 相同，则按 k 升序（从0到大）排列。
        sort(people.begin(), people.end(), cmp);
        vector<vector<int>> queue;
        for(vector<int>& person : people){
            // 注意people已经是按照h降序排序的
            queue.insert(queue.begin() + person[1], person);
        }
        return queue;
    }
private:
    // h降序，k升序
    static bool cmp(vector<int>& vec1, vector<int>& vec2){
        // 如果身高不同,按身高降序
        if(vec1[0] != vec2[0]) return vec1[0] > vec2[0];
        // 如果 身高相同，按k升序
        else return vec1[1] < vec2[1];
    }
};
```

[452. 用最少数量的箭引爆气球 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/)

局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。

这道题是“区间调度”问题的一个经典变种。问题可以被翻译为： **给定一堆区间 `[start, end]`，求最少需要多少个点，才能保证每个区间内至少有一个点。**

```cpp
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        // 按照结束点升序排序
        sort(points.begin(), points.end(), cmp);
        
        // 寻找每一个气球的x_end射
        int res = 1;
        int x = points[0][1];
        for(int i = 1; i < points.size(); i++){
            // 由于是按照结束点升序排序，故只要起始点小于射击点气球就能被射中
            // 这里判断没射中的情况
            if(points[i][0] > x){
                res++;
                x = points[i][1];
            }
            // 射中了直接走下一轮循环
        }
        return res;
    }
private:
    static bool cmp(vector<int>& vec1, vector<int>& vec2){
        if(vec1[1] != vec2[1]) return vec1[1] < vec2[1];
        // 如果结束点一样，按照起始点升序排序
        return vec1[0] < vec2[0];
    }
};
```

[435. 无重叠区间 - 力扣（LeetCode）](https://leetcode.cn/problems/non-overlapping-intervals/description/)

这道题问的是“最少移除多少个”，我们可以反过来想：**最多能保留多少个互不重叠的区间？**

总区间数 - 最多保留的区间数 = 最少移除的区间数

要保留最多的区间，我们的贪心策略应该是：

1. **选择结束时间最早的那个区间。**
2. **为什么？** 因为它最早结束，为后面的区间留出了最多的空间，这样我们才有可能保留更多的区间。

[763. 划分字母区间 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-labels/)

自己写的JB解法：

```cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.size() == 1) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int res = 0;
        int cur = 0;
        // 正序遍历就好，只保留最早结束的区间，为后面的区间留出更多的空余
        for(int i = 1; i < intervals.size(); i++){
            if(intervals[cur][1] > intervals[i][0]){
                res++;
            }
            else cur = i;
        }
        return res;
    }
private:
    static bool cmp(vector<int>& vec1, vector<int>& vec2){
        if(vec1[1] != vec2[1]) return vec1[1] < vec2[1];
        return vec1[0] < vec2[0];
    }
};
```

贪心算法：找到最大下标

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> max_index(26, 0);
        // 和跳越解法类似，存储最大下标
        for(int i = 0; i < s.size(); i++){
            max_index[s[i] - 'a'] = i;
        }
        int start = 0;
        int max_reach = 0;
        vector<int> res;
        for(int i = 0; i < s.size(); i++){
            max_reach = max(max_index[s[i] - 'a'], max_reach);
            if(i == max_reach){
                res.push_back(i - start + 1);
                start = i + 1;
            }
        }
        return res;
    }
};
```

[56. 合并区间 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-intervals/description/)

每一步都只关注“当前区间”和“上一个合并好的区间”，做出局部最优的决策（要么合并，要么新建），最终这个局部最优解的序列导向了全局最优解（所有区间都被正确合并）。

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // if(intervals.size() == 1) return intervals;
        sort(intervals.begin(), intervals.end(), cmp);
        vector<vector<int>> res;
        res.push_back(intervals[0]);
        for(int i = 1; i < intervals.size(); i++){
            if(intervals[i][0] <= res[res.size() - 1][1]){
                // if(intervals[i][1] > res[res.size() - 1][1]){
                //     res[res.size() - 1][1] = intervals[i][1];
                // }
                res.back()[1] = max(res.back()[1], intervals[i][1]);
            }
            else res.push_back(intervals[i]);
        }
        return res;
    }
private: 
    static bool cmp(vector<int>& vec1, vector<int>& vec2){
        if(vec1[0] != vec2[0]) return vec1[0] < vec2[0];
        return vec2[1] < vec2[1];
    }
};
```

[738. 单调递增的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/monotone-increasing-digits/description/)

挺难的。

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string strNum = to_string(n);
        int start = strNum.size();
        for (int i = strNum.size() - 2; i >= 0; i--) {
            if (strNum[i] > strNum[i+1]) {
                strNum[i]--;
                start = i + 1;
            }
        }
        for (int i = start; i < strNum.size(); i++) {
            strNum[i] = '9';
        }
        return stoi(strNum);
    }
};
```

[968. 监控二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-cameras/description/)

错误解法：没有考虑到一个节点有三种状态，监督者、未被监督和被监督节点。

```cpp
class Solution {
public:
    int minCameraCover(TreeNode* root) {
        // 初步想法：回溯时，若子节点没有被监视则父节点装上摄像头
        if(!root->left && !root->right) return 1;
        int res = 0;
        DFS(root, res);
        return res;
    }
private:
    bool DFS(TreeNode* root, int& res){
        // 如果是空节点，直接让父节点（叶子节点）假监督，这样叶子节点就不会被监督
        if(root == NULL) return true;
        // 回溯时
        // 如果孩子被监视了，自己不用监视
        if(DFS(root->left, res) && DFS(root->right, res)) return false;
        // 如果孩子没被监视，自己则要监视
        res++;
        return true;
    }
};
```

这道题需要结合节点值，对应上述三个关系。

```cpp
class Solution {
public:
    int minCameraCover(TreeNode* root) {
        if(!root->left && !root->right) return 1;
        int res = 0;
        // 如果根节点的两个子节点都被覆盖了但自己不是摄像机，需要给自己安一个摄像头
        if(DFS(root, res) == 0) res++;
        return res;
    }
private:
    // 设置 0：未被覆盖 1：有摄像头 2：已被覆盖
    // 后续遍历
    int DFS(TreeNode* root, int& res){
        if(root == NULL) return 2;
        int left = DFS(root->left, res);
        int right = DFS(root->right, res);
        // 如果子节点有任一未被覆盖则给自己安摄像头
        if(left == 0 || right == 0) {
            res++;
            return 1;
        }
        // 在上述条件外，如果子节点有任一有摄像头的则自己变为已覆盖
        if(left == 1 || right == 1) return 2;
        // 如果两个子节点都已经被覆盖了则自己仍然返回未被覆盖
        return 0;
    }
};
```

